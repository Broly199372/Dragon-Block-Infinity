=== src/main/java/com/dragonblockinfinity/registry/ModRegistry.java ===
package com.dragonblockinfinity.registry;

import com.dragonblockinfinity.block.ModBlocks;
import com.dragonblockinfinity.entity.ModEntities;
import com.dragonblockinfinity.item.ModItems;

/**
 * Classe central para registrar todos os componentes do mod
 */
public class ModRegistry {
    public static void register(net.minecraftforge.eventbus.api.IEventBus bus) {
        ModBlocks.register(bus);
        com.dragonblockinfinity.item.ModItems.register(bus);
        ModEntities.register();
    }
}
=== src/main/java/com/dragonblockinfinity/entity/ModEntities.java ===
package com.dragonblockinfinity.entity;

/**
 * Classe para registro de entidades customizadas do Dragon Block Infinity
 */
public class ModEntities {
    // Entidades do mod serão registradas aqui
    
    public static void register() {
        // Registrar entidades
    }
}
=== src/main/java/com/dragonblockinfinity/DragonBlockInfinity.java ===
package com.dragonblockinfinity;

import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.event.lifecycle.FMLClientSetupEvent;
import net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;
import net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;
import net.minecraftforge.fml.ModLoadingContext;
import net.minecraftforge.fml.event.lifecycle.FMLDedicatedServerSetupEvent;
import net.minecraftforge.fml.event.lifecycle.FMLLoadCompleteEvent;
import com.dragonblockinfinity.registry.ModRegistry;
import com.dragonblockinfinity.screen.ModScreens;
import com.dragonblockinfinity.handler.KeyHandler;

@Mod("dragonblockinfinity")
public class DragonBlockInfinity {

    public static final String MOD_ID = "dragonblockinfinity";

   public DragonBlockInfinity() {
      // Pega o barramento de eventos do Forge corretamente
      IEventBus modEventBus = FMLJavaModLoadingContext.get().getModEventBus();

      // Registra eventos do mod
      modEventBus.addListener(this::commonSetup);
      modEventBus.addListener(this::clientSetup);

      // Registra os componentes do mod
      ModRegistry.register(modEventBus);
      ModScreens.register();

      System.out.println("Dragon Block Infinity carregado com sucesso!");
   }

   private void commonSetup(final FMLCommonSetupEvent event) {
      // Configurações gerais do mod (execução do lado servidor/ambos)
   }

   private void clientSetup(final FMLClientSetupEvent event) {
      // Inicializações específicas do cliente
   }
}
=== src/main/java/com/dragonblockinfinity/status/Mnd.java ===
package com.dragonblockinfinity.status;

/**
 * Classe para gerenciar Mente (Mnd) - BÁSICO
 * Mnd controla inteligência, precisão e detecção
 */
public class Mnd {
    private int mind;  // Mente - inteligência
    
    public Mnd(int mind) {
        this.mind = mind;
    }
    
    // ===== GETTERS =====
    public int getMind() {
        return mind;
    }
    
    // ===== SETTERS =====
    public void setMind(int value) {
        this.mind = value;
    }
    
    public void addMind(int value) {
        this.mind += value;
    }
    
    // ===== BÁSICO =====
    /**
     * Bônus de precisão
     * Fórmula: Mind * 0.5%
     */
    public double getAccuracy() {
        return Math.min(mind * 0.5, 100.0);
    }
    
    /**
     * Bônus de detecção (detectar inimigos ocultos)
     * Fórmula: Mind * 1%
     */
    public double getDetectionRange() {
        return mind * 1.0;
    }
    
    /**
     * Resistência a confusão
     * Fórmula: Mind * 1%
     */
    public double getConfusionResistance() {
        return Math.min(mind * 1.0, 100.0);
    }
    
    @Override
    public String toString() {
        return "Mnd{" +
                "Mente=" + mind +
                ", Precisão=" + String.format("%.1f", getAccuracy()) + "%" +
                ", DetecçãoAlcance=" + String.format("%.1f", getDetectionRange()) + "m" +
                ", ResistênciàConfusão=" + String.format("%.1f", getConfusionResistance()) + "%" +
                '}';
    }
}
=== src/main/java/com/dragonblockinfinity/status/Str.java ===
package com.dragonblockinfinity.status;

/**
 * Classe para gerenciar o atributo Força (Str)
 * Str consome Stamina para fazer dano
 * Quanto maior Str em relação a Con, maior o dano mas maior o consumo
 */
public class Str {
    private int strength;      // Força - aumenta dano
    private int constitution;  // Constituição - limita consumo de Stamina
    private int currentStamina;    // Stamina atual
    private int maxStamina;    // Stamina máxima
    
    // ===== HABILIDADE SECRETA: MODO BERSERK =====
    private int berserkCharge;     // Acúmulo de poder (0-100)
    private int maxBerserkCharge;  // Máximo de acúmulo (100)
    private boolean isBerserk;     // Está em modo berserk?
    private double berserkDamageMultiplier;  // Multiplicador de dano em berserk
    
    public Str(int constitution) {
        this.strength = 10;
        this.constitution = constitution;
        this.maxStamina = constitution * 5; // Stamina máxima = Con * 5
        this.currentStamina = maxStamina;
        
        // Habilidade Secreta
        this.berserkCharge = 0;
        this.maxBerserkCharge = 100;
        this.isBerserk = false;
        this.berserkDamageMultiplier = 1.0;
    }
    
    // ===== GETTERS =====
    public int getStrength() {
        return strength;
    }
    
    public int getConstitution() {
        return constitution;
    }
    
    public int getCurrentStamina() {
        return currentStamina;
    }
    
    public int getMaxStamina() {
        return maxStamina;
    }
    
    // ===== SETTERS =====
    public void setStrength(int strength) {
        this.strength = strength;
    }
    
    public void setConstitution(int constitution) {
        this.constitution = constitution;
        this.maxStamina = constitution * 5;
    }
    
    public void setCurrentStamina(int stamina) {
        this.currentStamina = Math.max(0, Math.min(stamina, maxStamina));
    }
    
    // ===== ADIÇÕES =====
    public void addStrength(int value) {
        this.strength += value;
    }
    
    public void addStamina(int value) {
        this.currentStamina = Math.min(currentStamina + value, maxStamina);
    }
    
    public void removeStamina(int value) {
        this.currentStamina = Math.max(0, currentStamina - value);
    }
    
    // ===== CÁLCULOS DE DANO =====
    /**
     * Calcula dano padrão quando Stamina = 0
     * Fórmula: (Força * 0.5) + 2
     */
    public int getDefaultDamage() {
        return (int)(strength * 0.5) + 2;
    }
    
    /**
     * Calcula o dano base da força quando tem stamina
     * Fórmula: (Força * 1.5) + 5
     */
    public int getBaseDamage() {
        if (currentStamina == 0) {
            return getDefaultDamage();
        }
        return (int)(strength * 1.5) + 5;
    }
    
    /**
     * Calcula consumo de Stamina baseado na diferença Str - Con
     * Fórmula: 5 + (Str - Con) * 0.5
     * Mínimo de 3 de consumo
     */
    public int getStaminaCost() {
        int difference = strength - constitution;
        int cost = 5 + (int)(difference * 0.5);
        return Math.max(3, cost);
    }
    
    /**
     * Calcula dano com a quantidade de stamina gasta
     * Quanto mais stamina consumir, mais dano faz
     */
    public int calculateDamageWithStamina(int staminaCost) {
        int baseDamage = getBaseDamage();
        
        // Se não tem stamina suficiente, faz dano padrão
        if (currentStamina < staminaCost) {
            return getDefaultDamage();
        }
        
        // Quanto maior o custo de stamina, maior o multiplicador de dano
        double staminaMultiplier = 1.0 + (staminaCost * 0.1);
        return (int)(baseDamage * staminaMultiplier);
    }
    
    /**
     * Executa um ataque consumindo stamina
     * Retorna o dano feito, ou dano padrão se não tiver stamina
     */
    public int executeAttack() {
        int staminaCost = getStaminaCost();
        int damage = calculateDamageWithStamina(staminaCost);
        
        // Consome stamina
        if (currentStamina >= staminaCost) {
            removeStamina(staminaCost);
        }
        
        return damage;
    }
    
    /**
     * Verifica se tem stamina suficiente para atacar normalmente
     */
    public boolean hasEnoughStamina() {
        return currentStamina >= getStaminaCost();
    }
    
    @Override
    public String toString() {
        return "Str{" +
                "Força=" + strength +
                ", Constituição=" + constitution +
                ", Stamina=" + currentStamina + "/" + maxStamina +
                ", DanoBase=" + getBaseDamage() +
                ", DanoPadrão=" + getDefaultDamage() +
                ", CustoStamina=" + getStaminaCost() +
                ", BerserkCharge=" + berserkCharge + "/" + maxBerserkCharge +
                ", Berserk=" + (isBerserk ? "ATIVO" : "Inativo") +
                '}';
    }
    
    // ===== HABILIDADE SECRETA: MODO BERSERK =====
    /**
     * HABILIDADE SECRETA - MODO BERSERK
     * 
     * Quanto mais dano o jogador leva, mais energia ele acumula (Berserk Charge)
     * Quando atinge 100 de carga, pode ativar um ataque devastador
     * Cada ponto de Berserk aumenta 1% de dano
     * 
     * Em Berserk:
     * - Dano aumenta em até 100% (2x)
     * - Consumo de Stamina é reduzido em 50%
     * - Tempo limitado (precisa gastar a carga)
     */
    
    public int getBerserkCharge() {
        return berserkCharge;
    }
    
    public boolean isBerserkMode() {
        return isBerserk;
    }
    
    public double getBerserkDamageMultiplier() {
        return berserkDamageMultiplier;
    }
    
    /**
     * Quando o jogador leva dano, ganha Berserk Charge
     * Quanto maior o dano levado, mais charge ganha
     */
    public void accumulateBerserkCharge(int damageReceived) {
        if (isBerserk) return; // Não acumula em berserk
        
        // Acumula 2 pontos de charge por cada ponto de dano levado
        int chargeGain = Math.min(damageReceived * 2, maxBerserkCharge - berserkCharge);
        berserkCharge += chargeGain;
        
        // Se atingiu 100, entra automaticamente em berserk
        if (berserkCharge >= maxBerserkCharge) {
            activateBerserk();
        }
    }
    
    /**
     * Ativa o modo Berserk
     * Aumenta dano baseado na carga acumulada
     */
    private void activateBerserk() {
        isBerserk = true;
        // Multiplicador varia de 1.0 (0 charge) até 2.0 (100 charge)
        berserkDamageMultiplier = 1.0 + (berserkCharge / (double) maxBerserkCharge);
    }
    
    /**
     * Calcula dano com multiplicador de Berserk
     */
    public int calculateBerserkDamage(int baseDamage) {
        return (int)(baseDamage * berserkDamageMultiplier);
    }
    
    /**
     * Calcula consumo de Stamina reduzido em Berserk (50% menos)
     */
    public int getBerserkStaminaCost(int normalCost) {
        if (!isBerserk) return normalCost;
        return (int)(normalCost * 0.5);
    }
    
    /**
     * Executa ataque em modo Berserk e consome a carga
     * Quanto mais carga tinha, mais dano faz
     */
    public int executeBerserkAttack() {
        if (!isBerserk || berserkCharge <= 0) {
            return executeAttack(); // Ataque normal se não está em berserk
        }
        
        int baseDamage = getBaseDamage();
        int berserkDamage = calculateBerserkDamage(baseDamage);
        
        // Consome menos stamina em Berserk
        int staminaCost = getBerserkStaminaCost(getStaminaCost());
        if (currentStamina >= staminaCost) {
            removeStamina(staminaCost);
        }
        
        // Consome toda a carga de Berserk
        int damageBonus = (int)(strength * (berserkCharge / 10.0)); // Bônus baseado na carga
        berserkCharge = 0;
        isBerserk = false;
        berserkDamageMultiplier = 1.0;
        
        return berserkDamage + damageBonus;
    }
    
    /**
     * Cancelar modo Berserk manualmente (perde a carga)
     */
    public void cancelBerserk() {
        isBerserk = false;
        berserkCharge = 0;
        berserkDamageMultiplier = 1.0;
    }
    
    /**
     * Verifica se pode ativar Berserk (está em 100% de carga)
     */
    public boolean canActivateBerserk() {
        return berserkCharge >= maxBerserkCharge;
    }
    
    /**
     * Mostra informações do Berserk
     */
    public String getBerserkInfo() {
        return "=== MODO BERSERK (HABILIDADE SECRETA) ===\n" +
                "Carga Acumulada: " + berserkCharge + "/" + maxBerserkCharge + "\n" +
                "Status: " + (isBerserk ? "ATIVO - Multiplicador: " + String.format("%.1f", berserkDamageMultiplier) + "x" : "Inativo") + "\n" +
                "Dano Adicional: " + (int)(strength * (berserkCharge / 10.0)) + "\n" +
                "Consumo de Stamina Reduzido: 50% em Berserk\n" +
                "Dica: Leve dano para acumular carga e ativar o Berserk!";
    }
}
=== src/main/java/com/dragonblockinfinity/status/Dex.java ===
package com.dragonblockinfinity.status;

/**
 * Classe para gerenciar Destreza (Dex)
 * Dex se relaciona com Str do inimigo para esquiva, redução de dano e knockback
 * Quanto maior Dex em relação a Str do inimigo, mais imune fica
 */
public class Dex {
    private int dexterity;
    
    public Dex(int dexterity) {
        this.dexterity = dexterity;
    }
    
    // ===== GETTERS =====
    public int getDexterity() {
        return dexterity;
    }
    
    // ===== SETTERS =====
    public void setDexterity(int dexterity) {
        this.dexterity = dexterity;
    }
    
    public void addDexterity(int value) {
        this.dexterity += value;
    }
    
    // ===== CÁLCULOS DE RELAÇÃO DEX vs STR =====
    /**
     * Calcula o multiplicador de Dex em relação a Str do inimigo
     * Fórmula: Dex / Str do inimigo
     */
    public double getDexMultiplier(int enemyStrength) {
        if (enemyStrength <= 0) return 999; // Sem inimigo, defesa infinita
        return (double) dexterity / enemyStrength;
    }
    
    /**
     * Retorna uma descrição do nível de vantagem
     */
    public String getDexAdvantageLevel(int enemyStrength) {
        double multiplier = getDexMultiplier(enemyStrength);
        
        if (multiplier >= 4.0) return "DOMINANTE (4x+)";
        if (multiplier >= 3.0) return "SUPERIOR (3x+)";
        if (multiplier >= 2.0) return "VANTAGEM (2x+)";
        if (multiplier >= 1.5) return "LEVE VANTAGEM (1.5x+)";
        return "NORMAL";
    }
    
    // ===== CHANCE DE ESQUIVA =====
    /**
     * Calcula chance de esquiva baseado na relação Dex vs Str do inimigo
     * 
     * Multiplicador < 1.5x: 0% de esquiva
     * Multiplicador 1.5x: 25% de esquiva
     * Multiplicador 2x: 50% de esquiva
     * Multiplicador 3x: 80% de esquiva
     * Multiplicador 4x+: 95% de esquiva
     */
    public double getDodgeChance(int enemyStrength) {
        double multiplier = getDexMultiplier(enemyStrength);
        
        if (multiplier < 1.5) {
            return 0.0;
        } else if (multiplier < 2.0) {
            // Entre 1.5x e 2x: aumenta de 25% para 50%
            return 0.25 + (multiplier - 1.5) * 0.5;
        } else if (multiplier < 3.0) {
            // Entre 2x e 3x: aumenta de 50% para 80%
            return 0.50 + (multiplier - 2.0) * 0.3;
        } else if (multiplier < 4.0) {
            // Entre 3x e 4x: aumenta de 80% para 95%
            return 0.80 + (multiplier - 3.0) * 0.15;
        } else {
            // 4x ou mais: 95%+
            return 0.95;
        }
    }
    
    // ===== REDUÇÃO DE DANO =====
    /**
     * Calcula redução de dano baseado na relação Dex vs Str
     * 
     * Multiplicador < 2x: 0% de redução
     * Multiplicador 2x: 20% de redução
     * Multiplicador 3x: 70% de redução
     * Multiplicador 4x+: 90% de redução
     */
    public double getDamageReduction(int enemyStrength) {
        double multiplier = getDexMultiplier(enemyStrength);
        
        if (multiplier < 2.0) {
            return 0.0;
        } else if (multiplier < 3.0) {
            // Entre 2x e 3x: aumenta de 20% para 70%
            return 0.20 + (multiplier - 2.0) * 0.5;
        } else if (multiplier < 4.0) {
            // Entre 3x e 4x: aumenta de 70% para 90%
            return 0.70 + (multiplier - 3.0) * 0.2;
        } else {
            // 4x ou mais: 90%+
            return 0.90;
        }
    }
    
    /**
     * Calcula o dano final após redução por Dex
     */
    public int calculateFinalDamage(int incomingDamage, int enemyStrength) {
        double reduction = getDamageReduction(enemyStrength);
        int reducedDamage = (int)(incomingDamage * (1.0 - reduction));
        return Math.max(0, reducedDamage); // Mínimo 0
    }
    
    // ===== KNOCKBACK =====
    /**
     * Calcula knockback recebido baseado em Dex
     * 
     * Multiplicador < 2x: knockback normal (1.0x)
     * Multiplicador 2x: knockback reduzido (0.5x)
     * Multiplicador 3x: knockback mínimo (0.1x)
     * Multiplicador 4x+: sem knockback (0.0x)
     */
    public double getKnockbackMultiplier(int enemyStrength) {
        double multiplier = getDexMultiplier(enemyStrength);
        
        if (multiplier < 2.0) {
            return 1.0;
        } else if (multiplier < 3.0) {
            // Entre 2x e 3x: reduz de 1.0 para 0.1
            return 1.0 - (multiplier - 2.0) * 0.9;
        } else if (multiplier < 4.0) {
            // Entre 3x e 4x: reduz de 0.1 para 0.0
            return 0.1 - (multiplier - 3.0) * 0.1;
        } else {
            // 4x ou mais: sem knockback
            return 0.0;
        }
    }
    
    // ===== CHANCE DE ACERTAR (REVERSO) =====
    /**
     * Quando DEX é muito maior que STR, o inimigo tem dificuldade de acertar
     * 
     * Multiplicador < 3x: o inimigo consegue atacar normal
     * Multiplicador 3x: inimigo tem 50% de chance de acertar
     * Multiplicador 4x+: inimigo só consegue atacar 5% das vezes (fica parado)
     */
    public double getEnemyAccuracyReduction(int enemyStrength) {
        double multiplier = getDexMultiplier(enemyStrength);
        
        if (multiplier < 3.0) {
            return 1.0; // Inimigo consegue atacar 100%
        } else if (multiplier < 4.0) {
            // Entre 3x e 4x: reduz de 100% para 50%
            return 1.0 - (multiplier - 3.0) * 0.5;
        } else {
            // 4x ou mais: inimigo tem só 5% de chance de acertar
            return 0.05;
        }
    }
    
    // ===== ROLAGEM DE ESQUIVA =====
    /**
     * Testa se conseguiu esquivar
     */
    public boolean rollDodge(int enemyStrength) {
        return Math.random() < getDodgeChance(enemyStrength);
    }
    
    /**
     * Verifica se é DOMINANTE (4x+) - praticamente fica parado
     */
    public boolean isDominant(int enemyStrength) {
        return getDexMultiplier(enemyStrength) >= 4.0;
    }
    
    /**
     * Verifica se tem VANTAGEM SUPERIOR (3x+)
     */
    public boolean isSuperior(int enemyStrength) {
        return getDexMultiplier(enemyStrength) >= 3.0;
    }
    
    /**
     * Verifica se tem VANTAGEM (2x+)
     */
    public boolean hasAdvantage(int enemyStrength) {
        return getDexMultiplier(enemyStrength) >= 2.0;
    }
    
    /**
     * Verifica se tem LEVE VANTAGEM (1.5x+)
     */
    public boolean hasLightAdvantage(int enemyStrength) {
        return getDexMultiplier(enemyStrength) >= 1.5;
    }
    
    @Override
    public String toString() {
        return "Dex{" +
                "Destreza=" + dexterity +
                '}';
    }
    
    /**
     * Método para mostrar comparação com inimigo
     */
    public String compareWithEnemy(int enemyStrength) {
        double multiplier = getDexMultiplier(enemyStrength);
        return "=== ANÁLISE DE COMBATE ===\n" +
                "Sua Destreza: " + dexterity + "\n" +
                "Força do Inimigo: " + enemyStrength + "\n" +
                "Multiplicador: " + String.format("%.2f", multiplier) + "x\n" +
                "Nível: " + getDexAdvantageLevel(enemyStrength) + "\n" +
                "\nEsquiva: " + String.format("%.1f", getDodgeChance(enemyStrength) * 100) + "%\n" +
                "Redução de Dano: " + String.format("%.1f", getDamageReduction(enemyStrength) * 100) + "%\n" +
                "Knockback: " + String.format("%.1f", getKnockbackMultiplier(enemyStrength) * 100) + "%\n" +
                "Acurácia do Inimigo: " + String.format("%.1f", getEnemyAccuracyReduction(enemyStrength) * 100) + "%\n";
    }
}
=== src/main/java/com/dragonblockinfinity/status/Con.java ===
package com.dragonblockinfinity.status;

/**
 * Classe para gerenciar Constituição (Con) com vida, stamina e regeneração
 */
public class Con {
    private int constitution;
    private int currentHealth;
    private int maxHealth;
    private int currentStamina;
    private int maxStamina;
    
    // Regeneração
    private double healthRegenRate;    // % da vida máxima por tick
    private double staminaRegenRate;   // % da stamina máxima por tick
    
    public Con(int constitution) {
        this.constitution = constitution;
        this.maxHealth = constitution * 5;
        this.currentHealth = maxHealth;
        this.maxStamina = constitution * 5;
        this.currentStamina = maxStamina;
        
        // Taxa de regen padrão
        this.healthRegenRate = 0.01;    // 1% da vida por tick
        this.staminaRegenRate = 0.03;   // 3% da stamina por tick
    }
    
    // ===== GETTERS =====
    public int getConstitution() {
        return constitution;
    }
    
    public int getCurrentHealth() {
        return currentHealth;
    }
    
    public int getMaxHealth() {
        return maxHealth;
    }
    
    public int getCurrentStamina() {
        return currentStamina;
    }
    
    public int getMaxStamina() {
        return maxStamina;
    }
    
    public double getHealthRegenRate() {
        return healthRegenRate;
    }
    
    public double getStaminaRegenRate() {
        return staminaRegenRate;
    }
    
    // ===== SETTERS =====
    public void setConstitution(int value) {
        this.constitution = value;
        this.maxHealth = constitution * 5;
        if (currentHealth > maxHealth) {
            currentHealth = maxHealth;
        }
        this.maxStamina = constitution * 5;
        if (currentStamina > maxStamina) {
            currentStamina = maxStamina;
        }
    }
    
    public void setHealthRegenRate(double rate) {
        this.healthRegenRate = Math.max(0, Math.min(rate, 1.0)); // Limita entre 0 e 1
    }
    
    public void setStaminaRegenRate(double rate) {
        this.staminaRegenRate = Math.max(0, Math.min(rate, 1.0)); // Limita entre 0 e 1
    }
    
    // ===== ADIÇÕES =====
    public void addConstitution(int value) {
        setConstitution(constitution + value);
    }
    
    // ===== VIDA =====
    public void heal(int amount) {
        currentHealth = Math.min(currentHealth + amount, maxHealth);
    }
    
    public void takeDamage(int amount) {
        currentHealth = Math.max(0, currentHealth - amount);
    }
    
    public int getHealthDeficit() {
        return maxHealth - currentHealth;
    }
    
    public double getHealthPercentage() {
        return (double) currentHealth / maxHealth;
    }
    
    // ===== STAMINA =====
    public void restoreStamina(int amount) {
        currentStamina = Math.min(currentStamina + amount, maxStamina);
    }
    
    public void consumeStamina(int amount) {
        currentStamina = Math.max(0, currentStamina - amount);
    }
    
    public int getStaminaDeficit() {
        return maxStamina - currentStamina;
    }
    
    public double getStaminaPercentage() {
        return (double) currentStamina / maxStamina;
    }
    
    // ===== REGENERAÇÃO =====
    /**
     * Regenera vida baseado na taxa de regeneração
     * Retorna a quantidade de vida regenerada
     */
    public int regenerateHealth() {
        int regenAmount = (int)(maxHealth * healthRegenRate);
        heal(regenAmount);
        return regenAmount;
    }
    
    /**
     * Regenera stamina baseado na taxa de regeneração
     * Retorna a quantidade de stamina regenerada
     */
    public int regenerateStamina() {
        int regenAmount = (int)(maxStamina * staminaRegenRate);
        restoreStamina(regenAmount);
        return regenAmount;
    }
    
    /**
     * Regenera vida E stamina ao mesmo tempo (tick de regen)
     */
    public void tickRegeneration() {
        regenerateHealth();
        regenerateStamina();
    }
    
    /**
     * Calcula quantidade de vida regenerada por segundo
     * Baseado na taxa e constituição
     */
    public int getHealthRegenPerSecond() {
        return (int)(maxHealth * healthRegenRate);
    }
    
    /**
     * Calcula quantidade de stamina regenerada por segundo
     */
    public int getStaminaRegenPerSecond() {
        return (int)(maxStamina * staminaRegenRate);
    }
    
    // ===== BÔNUS =====
    /**
     * Bônus de vida: Con * 5
     */
    public int getLifeBonus() {
        return constitution * 5;
    }
    
    /**
     * Bônus de stamina: Con * 5
     */
    public int getStaminaBonus() {
        return constitution * 5;
    }
    
    /**
     * Quanto maior a constituição, melhor a regen
     */
    public void boostRegenFromConstitution() {
        // Aumenta taxa de regen em 0.1% por ponto de Con
        double bonus = constitution * 0.001;
        this.healthRegenRate = Math.min(healthRegenRate + bonus, 0.2);  // Máx 20%
        this.staminaRegenRate = Math.min(staminaRegenRate + bonus, 0.3); // Máx 30%
    }
    
    @Override
    public String toString() {
        return "Con{" +
                "Constituição=" + constitution +
                ", Vida=" + currentHealth + "/" + maxHealth + 
                " (" + String.format("%.1f", getHealthPercentage() * 100) + "%)" +
                ", Stamina=" + currentStamina + "/" + maxStamina +
                " (" + String.format("%.1f", getStaminaPercentage() * 100) + "%)" +
                ", RegenVida=" + getHealthRegenPerSecond() + "/s" +
                ", RegenStamina=" + getStaminaRegenPerSecond() + "/s" +
                '}';
    }
}

class Stamina {
    private int stamina;
    
    public Stamina() {
        this.stamina = 0;
    }
    
    public int getStamina() {
        return stamina;
    }
    
    public void setStamina(int value) {
        this.stamina = value;
    }
    
    public void addStamina(int value) {
        this.stamina += value;
    }
    
    public int getStaminaBonus() {
        return stamina * 6;
    }
}
=== src/main/java/com/dragonblockinfinity/status/Spi.java ===
package com.dragonblockinfinity.status;

/**
 * Classe para gerenciar Espírito (Spi) - Ki Máximo
 * Spi controla a quantidade de Ki disponível
 * Habilidade Secreta: OPRESSÃO DE KI
 * - Causa lentidão no chão
 * - Impede o player de voar se o Spi for muito maior
 */
public class Spi {
    private int spirit;           // Espírito - Ki máximo
    private int currentKi;        // Ki atual
    private int maxKi;            // Ki máximo
    private double kiRegenRate;   // Taxa de regeneração de Ki por segundo
    
    // ===== HABILIDADE SECRETA: OPRESSÃO DE KI =====
    private int oppressionCharge;      // Carga de opressão (0-100)
    private int maxOppressionCharge;   // Máximo de carga (100)
    private boolean isOppressing;      // Está oprimindo?
    private double slowdownIntensity;  // Intensidade de lentidão (0-100%)
    
    public Spi(int spirit) {
        this.spirit = spirit;
        this.maxKi = spirit * 10;  // Ki máximo = Spi * 10
        this.currentKi = maxKi;
        this.kiRegenRate = 0.5;    // 0.5% de regen por tick
        
        // Habilidade Secreta
        this.oppressionCharge = 0;
        this.maxOppressionCharge = 100;
        this.isOppressing = false;
        this.slowdownIntensity = 0.0;
    }
    
    // ===== GETTERS =====
    public int getSpirit() {
        return spirit;
    }
    
    public int getCurrentKi() {
        return currentKi;
    }
    
    public int getMaxKi() {
        return maxKi;
    }
    
    public double getKiRegenRate() {
        return kiRegenRate;
    }
    
    // ===== SETTERS =====
    public void setSpirit(int spirit) {
        this.spirit = spirit;
        this.maxKi = spirit * 10;
        if (currentKi > maxKi) {
            currentKi = maxKi;
        }
    }
    
    public void setKiRegenRate(double rate) {
        this.kiRegenRate = Math.max(0, Math.min(rate, 1.0));
    }
    
    public void addSpirit(int value) {
        setSpirit(spirit + value);
    }
    
    // ===== KI MANAGEMENT =====
    public void consumeKi(int amount) {
        currentKi = Math.max(0, currentKi - amount);
    }
    
    public void restoreKi(int amount) {
        currentKi = Math.min(currentKi + amount, maxKi);
    }
    
    public void regenerateKi() {
        int regenAmount = (int)(maxKi * (kiRegenRate / 100.0));
        restoreKi(regenAmount);
    }
    
    public boolean hasKi(int required) {
        return currentKi >= required;
    }
    
    public double getKiPercentage() {
        return (double) currentKi / maxKi;
    }
    
    // ===== HABILIDADE SECRETA: OPRESSÃO DE KI =====
    /**
     * HABILIDADE SECRETA - OPRESSÃO DE KI
     * 
     * A opressão de Ki funciona baseada na diferença de Spi entre jogadores
     * Quanto maior o Spi do jogador 1 em relação ao do jogador 2,
     * mais ele consegue oprimir o outro
     * 
     * Efeitos:
     * - Causa lentidão no chão (até 100% de redução de velocidade)
     * - Impede o player oprimido de voar se a opressão for muito forte
     * - Reduz a velocidade de regen de Ki do oprimido
     */
    
    public int getOppressionCharge() {
        return oppressionCharge;
    }
    
    public boolean isOppressing() {
        return isOppressing;
    }
    
    public double getSlowdownIntensity() {
        return slowdownIntensity;
    }
    
    /**
     * Calcula o nível de opressão baseado na diferença de Spi
     * Fórmula: (Spi próprio - Spi inimigo) / Spi próprio * 100
     */
    public double calculateOppression(int enemySpi) {
        if (enemySpi <= 0) return 100.0;
        
        double difference = spirit - enemySpi;
        if (difference <= 0) return 0.0; // Sem opressão se Spi for menor
        
        return Math.min(100.0, (difference / spirit) * 100);
    }
    
    /**
     * Ativa a opressão de Ki contra um inimigo
     * Requer bastante Ki para manter ativa
     */
    public boolean activateOppressionField(int enemySpi) {
        if (currentKi < 50) {
            return false; // Precisa de pelo menos 50 de Ki
        }
        
        isOppressing = true;
        slowdownIntensity = calculateOppression(enemySpi);
        return true;
    }
    
    /**
     * Desativa a opressão de Ki
     */
    public void deactivateOppressionField() {
        isOppressing = false;
        slowdownIntensity = 0.0;
        oppressionCharge = 0;
    }
    
    /**
     * Mantém a opressão ativa consumindo Ki continuamente
     * Quanto mais forte a opressão, mais Ki consome por tick
     */
    public void tickOppressionField() {
        if (!isOppressing) return;
        
        // Consome Ki baseado na intensidade da opressão
        int kiCost = (int)(slowdownIntensity * 0.5);
        consumeKi(kiCost);
        
        // Acumula carga
        oppressionCharge = Math.min(maxOppressionCharge, (int)slowdownIntensity);
        
        // Se acabar o Ki, deativa automaticamente
        if (currentKi <= 0) {
            deactivateOppressionField();
        }
    }
    
    /**
     * Calcula quanto o player é desacelerado (0-1, onde 1 é 100% de lentidão)
     * Quanto maior a opressão, mais lento fica
     */
    public double getMovementSpeedMultiplier(int enemySpi) {
        if (!isOppressing) return 1.0;
        
        double oppression = calculateOppression(enemySpi);
        // Reduz velocidade de 0% até 80% baseado na opressão
        return 1.0 - (oppression / 100.0 * 0.8);
    }
    
    /**
     * Verifica se o player pode voar com essa opressão
     * Se a opressão for >= 50%, não consegue voar
     */
    public boolean canFly(int enemySpi) {
        if (!isOppressing) return true;
        
        double oppression = calculateOppression(enemySpi);
        return oppression < 50.0; // Só consegue voar se opressão < 50%
    }
    
    /**
     * Reduz a taxa de regen de Ki do inimigo
     */
    public double getEnemyKiRegenPenalty(int enemySpi) {
        if (!isOppressing) return 1.0;
        
        double oppression = calculateOppression(enemySpi);
        // Reduz regen de 0% até 70% baseado na opressão
        return 1.0 - (oppression / 100.0 * 0.7);
    }
    
    /**
     * Mostra informações da opressão
     */
    public String getOppressionInfo(int enemySpi) {
        double oppression = calculateOppression(enemySpi);
        return "=== OPRESSÃO DE KI (HABILIDADE SECRETA) ===\n" +
                "Spi Próprio: " + spirit + " | Spi Inimigo: " + enemySpi + "\n" +
                "Nível de Opressão: " + String.format("%.1f", oppression) + "%\n" +
                "Status: " + (isOppressing ? "ATIVA" : "Inativa") + "\n" +
                "Lentidão do Inimigo: " + String.format("%.1f", (1.0 - getMovementSpeedMultiplier(enemySpi)) * 100) + "%\n" +
                "Pode Voar: " + (canFly(enemySpi) ? "SIM" : "NÃO") + "\n" +
                "Regen de Ki Reduzida: " + String.format("%.1f", (1.0 - getEnemyKiRegenPenalty(enemySpi)) * 100) + "%";
    }
    
    @Override
    public String toString() {
        return "Spi{" +
                "Espírito=" + spirit +
                ", Ki=" + currentKi + "/" + maxKi +
                " (" + String.format("%.1f", getKiPercentage() * 100) + "%)" +
                ", RegenRate=" + kiRegenRate + "%" +
                ", Opressão=" + (isOppressing ? "ATIVA (" + (int)slowdownIntensity + "%)" : "Inativa") +
                '}';
    }
}
=== src/main/java/com/dragonblockinfinity/status/Will.java ===
package com.dragonblockinfinity.status;

/**
 * Classe para gerenciar Vontade (Will)
 * Will controla o dano de Ki (ataques de energia) e resistência mental
 */
public class Will {
    private int willpower;      // Vontade - aumenta dano de Ki
    private int spiritLevel;    // Nível de espírito (referência)
    
    public Will(int willpower, int spirit) {
        this.willpower = willpower;
        this.spiritLevel = spirit;
    }
    
    // ===== GETTERS =====
    public int getWillpower() {
        return willpower;
    }
    
    public int getSpiritLevel() {
        return spiritLevel;
    }
    
    // ===== SETTERS =====
    public void setWillpower(int value) {
        this.willpower = value;
    }
    
    public void setSpiritLevel(int spirit) {
        this.spiritLevel = spirit;
    }
    
    public void addWillpower(int value) {
        this.willpower += value;
    }
    
    // ===== DANO DE KI =====
    /**
     * Calcula dano base de ataque de Ki (Ki Blast, Foice Attack, etc)
     * Fórmula: (Will * 2) + 10
     */
    public int getKiBlastDamage() {
        return (willpower * 2) + 10;
    }
    
    /**
     * Calcula custo de Ki para executar um ataque
     * Fórmula: 20 + (Will / 2)
     */
    public int getKiCost() {
        return 20 + (willpower / 2);
    }
    
    /**
     * Calcula dano do Foice Attack (ataque mais forte)
     * Custa mais Ki e faz mais dano
     * Fórmula: Dano de Ki * 2.5
     */
    public int getFoiceAttackDamage() {
        return (int)(getKiBlastDamage() * 2.5);
    }
    
    /**
     * Calcula custo de Ki do Foice Attack
     * Custa 2.5x o normal
     */
    public int getFoiceAttackKiCost() {
        return (int)(getKiCost() * 2.5);
    }
    
    // ===== RESISTÊNCIA MENTAL =====
    /**
     * Resistência a efeitos de controle mental
     * Fórmula: Will * 2%
     */
    public double getMentalResistance() {
        return Math.min(willpower * 2.0, 100.0);
    }
    
    /**
     * Chance de resistir a um efeito negativo
     */
    public boolean resistNegativeEffect() {
        return Math.random() * 100 < getMentalResistance();
    }
    
    @Override
    public String toString() {
        return "Will{" +
                "Vontade=" + willpower +
                ", DanoKi=" + getKiBlastDamage() +
                ", CustoKi=" + getKiCost() +
                ", DanoFoice=" + getFoiceAttackDamage() +
                ", CustoFoice=" + getFoiceAttackKiCost() +
                ", ResistênciaMental=" + String.format("%.1f", getMentalResistance()) + "%" +
                '}';
    }
}
=== src/main/java/com/dragonblockinfinity/capability/PowerCapability.java ===
package com.dragonblockinfinity.capability;

/**
 * Capability para gerenciar o poder/energia dos jogadores
 */
public class PowerCapability {
    // Propriedades de poder dos jogadores serão armazenadas aqui
}
=== src/main/java/com/dragonblockinfinity/screen/ModScreens.java ===
package com.dragonblockinfinity.screen;

/**
 * Classe para registro de telas GUI customizadas
 */
public class ModScreens {
    
    /**
     * Registra todas as telas customizadas do mod
     */
    public static void register() {
        // Telas serão registradas aqui
    }
}
=== src/main/java/com/dragonblockinfinity/screen/Race3DRenderer.java ===
package com.dragonblockinfinity.screen;

import com.mojang.blaze3d.vertex.PoseStack;
import com.mojang.blaze3d.systems.RenderSystem;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.resources.ResourceLocation;
import com.dragonblockinfinity.race.RaceEnum;
import com.dragonblockinfinity.screen.CustomizationData;

/**
 * Renderizador 3D para modelos das raças no menu de seleção
 */
public class Race3DRenderer {
    
    /**
     * Renderiza um modelo 3D texturizado da raça
     */
    public static void renderRaceModel(GuiGraphics graphics, int x, int y, int width, int height,
                                       RaceEnum race, float rotationYaw, float rotationPitch) {
        // Camadas: body (músculos) -> skin (race) -> tint overlay -> olhos
        String bodyTex = getBodyTextureForRace(race);
        String raceTex = getTextureForRace(race);

        ResourceLocation body = new ResourceLocation("dragonblockinfinity", "textures/entity/" + bodyTex);
        ResourceLocation skin = new ResourceLocation("dragonblockinfinity", "textures/entity/race/" + raceTex);

        // Simular rotação 3D com deslocamento horizontal e leve escala
        float yawOffset = (float) Math.sin(Math.toRadians(rotationYaw)) * (width * 0.12f);
        float pitchOffset = (float) Math.sin(Math.toRadians(rotationPitch)) * (height * 0.06f);

        int bodyX = x - Math.round(yawOffset);
        int skinX = x + Math.round(yawOffset);
        int drawY = y - Math.round(pitchOffset);

        // Desenhar body (camada inferior)
        RenderSystem.setShaderColor(1f, 1f, 1f, 1f);
        graphics.blit(body, bodyX, drawY, 0, 0, width, height, width, height);

        // Desenhar skin por cima com tint aplicado (cor selecionada)
        int color = CustomizationData.getSelectedColor();
        float cr = ((color >> 16) & 0xFF) / 255f;
        float cg = ((color >> 8) & 0xFF) / 255f;
        float cb = (color & 0xFF) / 255f;

        RenderSystem.setShaderColor(cr, cg, cb, 1f);
        graphics.blit(skin, skinX, drawY, 0, 0, width, height, width, height);

        // Reset color
        RenderSystem.setShaderColor(1f, 1f, 1f, 1f);

        // Renderizar olhos por cima
        String eyeLeft = getEyeTexture(CustomizationData.getSelectedEyes(), true);
        String eyeRight = getEyeTexture(CustomizationData.getSelectedEyes(), false);
        if (eyeLeft != null && eyeRight != null) {
            ResourceLocation eyeL = new ResourceLocation("dragonblockinfinity", "textures/entity/customização/eye/" + eyeLeft);
            ResourceLocation eyeR = new ResourceLocation("dragonblockinfinity", "textures/entity/customização/eye/" + eyeRight);

            // posição relativa dos olhos dentro do preview (ajustável)
            int eyeW = Math.max(8, width / 8);
            int eyeH = Math.max(8, height / 16);
            int centerX = x + width / 2;
            int centerY = y + height / 2 - 8;
            int leftEyeX = centerX - (width / 6) - eyeW / 2;
            int rightEyeX = centerX + (width / 6) - eyeW / 2;
            int eyeY = centerY - eyeH / 2;

            graphics.blit(eyeL, leftEyeX, eyeY, 0, 0, eyeW, eyeH, eyeW, eyeH);
            graphics.blit(eyeR, rightEyeX, eyeY, 0, 0, eyeW, eyeH, eyeW, eyeH);
        }
    }
    
    /**
     * Renderiza apenas a textura da raça como sprite
     */
    public static void renderRaceTexture(GuiGraphics graphics, int x, int y, int width, int height,
                                         RaceEnum race) {
        String textureFile = getTextureForRace(race);
        ResourceLocation texture = new ResourceLocation("dragonblockinfinity", "textures/entity/race/" + textureFile);
        graphics.blit(texture, x, y, 0, 0, width, height, width, height);
    }
    
    /**
     * Obtém o arquivo de textura para cada raça
     */
    private static String getTextureForRace(RaceEnum race) {
        return switch (race) {
            case SAIYAN -> "sayajin.png";
            case HALF -> "fsayajin.png";
            case HUMAN -> "humano.png";
            case ARCONSIAN -> "arconsian.png";
            default -> "sayajin.png";
        };
    }
    
    /**
     * Obtém a textura do corpo para cada raça
     */
    public static String getBodyTextureForRace(RaceEnum race) {
        return switch (race) {
            case SAIYAN, HALF, HUMAN -> "musculosrace/musculos.png";
            case ARCONSIAN -> "musculosrace/musculos_arconsian.png";
            default -> "musculosrace/musculos.png";
        };
    }
    
    /**
     * Obtém textura auxiliar se existir
     */
    public static String getAuxTextureForRace(RaceEnum race) {
        return switch (race) {
            case SAIYAN, HALF, HUMAN -> "a_a.png"; // Usar a_a.png para roupas/aura
            case ARCONSIAN -> "mmenu_base.png"; // Arconsian usa base
            default -> "a_a.png";
        };
    }

    private static String getEyeTexture(int index, boolean left) {
        // Atualmente só um tipo de olhos implementado (index 0)
        if (index < 0) return null;
        return switch (index) {
            case 0 -> left ? "eye_1_left.png" : "eye_1_right.png";
            default -> left ? "eye_1_left.png" : "eye_1_right.png";
        };
    }
    
    /**
     * Preenche um retângulo com cor (função auxiliar)
     */
    // método placeholder caso necessário no futuro
    private static void fill(PoseStack poseStack, int x1, int y1, int x2, int y2, int color) {
        // Intencionalmente vazio — use a tela para desenhar retângulos de fundo
    }
}
=== src/main/java/com/dragonblockinfinity/screen/CustomizationData.java ===
package com.dragonblockinfinity.screen;

import com.dragonblockinfinity.race.RaceEnum;

/**
 * Dados simples de customização mantidos no cliente.
 */
public class CustomizationData {

    private static RaceEnum selectedRace = RaceEnum.SAIYAN;
    private static int selectedEyes = 0;
    private static int selectedColor = 0xFFFFCC88; // ARGB default (light race base)

    public static RaceEnum getSelectedRace() {
        return selectedRace;
    }

    public static void setSelectedRace(RaceEnum race) {
        selectedRace = race;
    }

    public static int getSelectedEyes() {
        return selectedEyes;
    }

    public static void setSelectedEyes(int idx) {
        selectedEyes = idx;
    }

    public static int getSelectedColor() {
        return selectedColor;
    }

    public static void setSelectedColor(int colorArgb) {
        selectedColor = colorArgb | 0xFF000000; // ensure alpha
    }
}
=== src/main/java/com/dragonblockinfinity/screen/CustomColorPickerScreen.java ===
package com.dragonblockinfinity.screen;

import com.mojang.blaze3d.vertex.PoseStack;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.network.chat.Component;

import java.util.function.IntConsumer;

public class CustomColorPickerScreen extends Screen {

    private final Screen parent;
    private final IntConsumer callback;
    private int r,g,b;

    private int paletteX, paletteY, paletteW = 220, paletteH = 20;
    private int sliderW = 220, sliderH = 12;

    public CustomColorPickerScreen(Screen parent, IntConsumer callback, int initialArgb) {
        super(Component.literal("Selecionar cor"));
        this.parent = parent;
        this.callback = callback;
        this.r = (initialArgb >> 16) & 0xFF;
        this.g = (initialArgb >> 8) & 0xFF;
        this.b = (initialArgb) & 0xFF;
    }

    @Override
    protected void init() {
        int midX = this.width / 2;
        int midY = this.height / 2;

        int btnW = 60, btnH = 20;
        this.addRenderableWidget(Button.builder(Component.literal("OK"), btn -> {
            int color = (0xFF << 24) | (r << 16) | (g << 8) | b;
            callback.accept(color);
            Minecraft.getInstance().setScreen(parent);
        }).bounds(midX - btnW - 10, midY + 80, btnW, btnH).build());

        this.addRenderableWidget(Button.builder(Component.literal("Cancelar"), btn -> {
            Minecraft.getInstance().setScreen(parent);
        }).bounds(midX + 10, midY + 80, btnW, btnH).build());

        paletteX = (this.width - paletteW) / 2;
        paletteY = midY - 10 - paletteH - 40; // posição acima dos sliders
    }

    @Override
    public boolean mouseDragged(double mouseX, double mouseY, int button, double dragX, double dragY) {
        if (button == 0) {
            handleSliderDrag((int)mouseX, (int)mouseY);
            return true;
        }
        return super.mouseDragged(mouseX, mouseY, button, dragX, dragY);
    }

    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (button == 0) {
            handleSliderDrag((int)mouseX, (int)mouseY);
            return true;
        }
        return super.mouseClicked(mouseX, mouseY, button);
    }

    private void handleSliderDrag(int mouseX, int mouseY) {
        int midY = this.height / 2;
        int rY = midY - 20;
        int gY = midY + 0;
        int bY = midY + 20;
        if (mouseY >= rY && mouseY <= rY + sliderH && mouseX >= paletteX && mouseX <= paletteX + sliderW) {
            r = Math.max(0, Math.min(255, (mouseX - paletteX) * 255 / sliderW));
        } else if (mouseY >= gY && mouseY <= gY + sliderH && mouseX >= paletteX && mouseX <= paletteX + sliderW) {
            g = Math.max(0, Math.min(255, (mouseX - paletteX) * 255 / sliderW));
        } else if (mouseY >= bY && mouseY <= bY + sliderH && mouseX >= paletteX && mouseX <= paletteX + sliderW) {
            b = Math.max(0, Math.min(255, (mouseX - paletteX) * 255 / sliderW));
        }
    }

    @Override
    public void render(GuiGraphics graphics, int mouseX, int mouseY, float partialTicks) {
        // Fundo escuro semi-transparente
        graphics.fill(0, 0, this.width, this.height, 0x77000000);
        int midX = this.width / 2;
        int midY = this.height / 2;

        // Painel central escuro
        int panelW = Math.max(320, paletteW + 80);
        int panelH = 260;
        int panelX = midX - panelW / 2;
        int panelY = midY - panelH / 2;
        graphics.fill(panelX, panelY, panelX + panelW, panelY + panelH, 0xCC000000);

        graphics.drawCenteredString(this.font, Component.literal("Selecionar cor base da raça"), midX, panelY + 8, 0xFFFFFF);

        // Desenhar paleta hue -> rainbow (dentro do painel)
        for (int i = 0; i < paletteW; i++) {
            float h = i / (float) paletteW;
            int col = 0xFF000000 | hsvToRgb(h, 1f, 1f);
            graphics.fill(paletteX + i, paletteY, paletteX + i + 1, paletteY + paletteH, col);
        }

        // Sliders R/G/B
        int rY = midY - 20 + 20;
        int gY = midY + 0 + 20;
        int bY = midY + 20 + 20;

        // Background bars
        graphics.fill(paletteX - 1, rY - 1, paletteX + sliderW + 1, rY + sliderH + 1, 0xFF333333);
        graphics.fill(paletteX - 1, gY - 1, paletteX + sliderW + 1, gY + sliderH + 1, 0xFF333333);
        graphics.fill(paletteX - 1, bY - 1, paletteX + sliderW + 1, bY + sliderH + 1, 0xFF333333);

        // Filled portions
        graphics.fill(paletteX, rY, paletteX + (r * sliderW / 255), rY + sliderH, (0xFF << 24) | (r << 16));
        graphics.fill(paletteX, gY, paletteX + (g * sliderW / 255), gY + sliderH, (0xFF << 24) | (g << 8));
        graphics.fill(paletteX, bY, paletteX + (b * sliderW / 255), bY + sliderH, (0xFF << 24) | b);

        // Labels
        graphics.drawString(this.font, "R: " + r, paletteX + paletteW + 10, rY, 0xFFFFFF);
        graphics.drawString(this.font, "G: " + g, paletteX + paletteW + 10, gY, 0xFFFFFF);
        graphics.drawString(this.font, "B: " + b, paletteX + paletteW + 10, bY, 0xFFFFFF);

        // Preview
        // Preview grande 64x64 centralizado dentro do painel
        int previewW = 64;
        int previewH = 64;
        int previewX = midX - previewW / 2;
        int previewY = panelY + 40;
        int previewColor = (0xFF << 24) | (r << 16) | (g << 8) | b;
        graphics.fill(previewX - 2, previewY - 2, previewX + previewW + 2, previewY + previewH + 2, 0xFF222222);
        graphics.fill(previewX, previewY, previewX + previewW, previewY + previewH, previewColor);

        super.render(graphics, mouseX, mouseY, partialTicks);
    }

    private int hsvToRgb(float h, float s, float v) {
        int i = (int) Math.floor(h * 6);
        float f = h * 6 - i;
        float p = v * (1 - s);
        float q = v * (1 - f * s);
        float t = v * (1 - (1 - f) * s);
        float r1 = 0, g1 = 0, b1 = 0;
        switch (i % 6) {
            case 0: r1 = v; g1 = t; b1 = p; break;
            case 1: r1 = q; g1 = v; b1 = p; break;
            case 2: r1 = p; g1 = v; b1 = t; break;
            case 3: r1 = p; g1 = q; b1 = v; break;
            case 4: r1 = t; g1 = p; b1 = v; break;
            case 5: r1 = v; g1 = p; b1 = q; break;
        }
        int ri = (int) (r1 * 255) & 0xFF;
        int gi = (int) (g1 * 255) & 0xFF;
        int bi = (int) (b1 * 255) & 0xFF;
        return (ri << 16) | (gi << 8) | bi;
    }
}
=== src/main/java/com/dragonblockinfinity/screen/CustomizationScreen.java ===
package com.dragonblockinfinity.screen;

import com.mojang.blaze3d.vertex.PoseStack;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.components.ImageButton;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.network.chat.Component;
import com.dragonblockinfinity.race.RaceEnum;
import net.minecraft.resources.ResourceLocation;

import java.util.List;

/**
 * Tela de customização simples — permite escolher raça e olhos.
 */
public class CustomizationScreen extends Screen {

    private int raceIndex = 0;
    private int eyesIndex = 0;
    private float modelYaw = 0f;
    private double lastMouseX = 0;
    private boolean dragging = false;
    private int previewX, previewY, previewW = 96, previewH = 128;

    private final List<RaceEnum> races = List.of(RaceEnum.values());
    private int colorBtnX, colorBtnY, colorBtnW = 12, colorBtnH = 12;

    public CustomizationScreen() {
        super(Component.literal("Customização"));
        RaceEnum current = CustomizationData.getSelectedRace();
        this.raceIndex = races.indexOf(current);
        this.eyesIndex = CustomizationData.getSelectedEyes();
    }

    @Override
    protected void init() {
        int midX = this.width / 2;
        int midY = this.height / 2;

        // Menu base (256x200) centralizado
        int menuW = 256, menuH = 200;
        int menuX = midX - menuW / 2;
        int menuY = midY - menuH / 2;

        // Usar botões pequenos (compactos) para arrow/color/miniaturas
        int btnW = 12, btnH = 12;
        // Posicionar setas/controles no lado direito do menu (vertical)
        int arrowRightX = menuX + menuW - 32;
        int arrowRightY = menuY + 30;
        int arrowLeftX = arrowRightX;
        int arrowLeftY = arrowRightY + 16;

        ResourceLocation leftTex = new ResourceLocation("dragonblockinfinity", "textures/gui/buttoes/seta_left.png");
        ResourceLocation rightTex = new ResourceLocation("dragonblockinfinity", "textures/gui/buttoes/seta_right.png");
        // colocar o botão com icone de seta esquerda na posição esquerda
        this.addRenderableWidget(new ImageButton(arrowLeftX, arrowLeftY, btnW, btnH, 0, 0, 0, leftTex, btnW, btnH, b -> changeRace(-1)));
        // colocar o botão com icone de seta direita na posição direita
        this.addRenderableWidget(new ImageButton(arrowRightX, arrowRightY, btnW, btnH, 0, 0, 0, rightTex, btnW, btnH, b -> changeRace(1)));

        // Botão de cor: posicionado acima do menu (CIMA, não lado nem embaixo)
        colorBtnW = 12; colorBtnH = 12;
        colorBtnX = menuX + menuW - colorBtnW - 8;
        colorBtnY = menuY - colorBtnH - 6;
        this.addRenderableWidget(Button.builder(Component.literal(""), btn -> openColorPicker()).bounds(colorBtnX, colorBtnY, colorBtnW, colorBtnH).build());

        // Botões de olhos mais abaixo dentro do menu
        int eyesY = menuY + 60;
        ResourceLocation rt = new ResourceLocation("dragonblockinfinity", "textures/gui/buttoes/rt.png");
        ResourceLocation rtn = new ResourceLocation("dragonblockinfinity", "textures/gui/buttoes/rtn.png");
        this.addRenderableWidget(new ImageButton(menuX + 12, eyesY, btnW, btnH, 0, 0, 0, rtn, btnW, btnH, b -> changeEyes(-1)));
        this.addRenderableWidget(new ImageButton(menuX + 12 + btnW + 6, eyesY, btnW, btnH, 0, 0, 0, rt, btnW, btnH, b -> changeEyes(1)));

        this.addRenderableWidget(Button.builder(Component.literal("Aplicar"), btn -> applyAndClose()).bounds(midX - 50, menuY + menuH - 36, 40, 20).build());
        this.addRenderableWidget(Button.builder(Component.literal("Fechar"), btn -> onClose()).bounds(midX + 10, menuY + menuH - 36, 40, 20).build());

        // Miniaturas pequenas (botões) ao lado direito
        int thumbW = 32, thumbH = 32;
        int thumbX = menuX + menuW - 84;
        int thumbY = menuY + 24;
        for (int i = 0; i < races.size(); i++) {
            int ty = thumbY + i * (thumbH + 6);
            final int idx = i;
            ResourceLocation tex = new ResourceLocation("dragonblockinfinity", "textures/entity/race/" + Race3DRenderer.getTextureForRace(races.get(i)));
            this.addRenderableWidget(new ImageButton(thumbX, ty, thumbW, thumbH, 0, 0, 0, tex, thumbW, thumbH, b -> {
                raceIndex = idx;
            }));
        }
    }

    private void changeRace(int delta) {
        raceIndex = (raceIndex + delta) % races.size();
        if (raceIndex < 0) raceIndex += races.size();
    }

    private void changeEyes(int delta) {
        // vamos supor 4 tipos de olhos por enquanto
        int max = 4;
        eyesIndex = (eyesIndex + delta) % max;
        if (eyesIndex < 0) eyesIndex += max;
    }

    private void applyAndClose() {
        CustomizationData.setSelectedRace(races.get(raceIndex));
        CustomizationData.setSelectedEyes(eyesIndex);
        onClose();
    }

    private void openColorPicker() {
        Minecraft.getInstance().setScreen(new CustomColorPickerScreen(this, color -> {
            CustomizationData.setSelectedColor(color);
        }, CustomizationData.getSelectedColor()));
    }

    @Override
    public boolean mouseDragged(double mouseX, double mouseY, int button, double dragX, double dragY) {
        if (button == 0 && dragging) {
            double delta = mouseX - lastMouseX;
            modelYaw += delta * 0.8f;
            lastMouseX = mouseX;
            return true;
        }
        return super.mouseDragged(mouseX, mouseY, button, dragX, dragY);
    }

    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (button == 0) {
            // detectar clique nas miniaturas de raça (lado direito)
            int menuW = 256;
            int menuX = this.width / 2 - menuW / 2;
            int menuY = this.height / 2 - 200 / 2;
            int thumbX = menuX + menuW - 84;
            int thumbY = menuY + 24;
            int thumbW = 32, thumbH = 32;
            if (mouseX >= thumbX && mouseX <= thumbX + thumbW) {
                int idx = (int) ((mouseY - thumbY) / (thumbH + 6));
                if (idx >= 0 && idx < races.size()) {
                    raceIndex = idx;
                    return true;
                }
            }

            // iniciar arraste somente se clicar dentro da área de preview
            if (mouseX >= previewX && mouseX <= previewX + previewW && mouseY >= previewY && mouseY <= previewY + previewH) {
                dragging = true;
                lastMouseX = mouseX;
                return true;
            }
        }
        return super.mouseClicked(mouseX, mouseY, button);
    }

    @Override
    public boolean mouseReleased(double mouseX, double mouseY, int button) {
        if (button == 0) {
            dragging = false;
            return true;
        }
        return super.mouseReleased(mouseX, mouseY, button);
    }

    @Override
    public void render(GuiGraphics graphics, int mouseX, int mouseY, float partialTicks) {
        graphics.fill(0, 0, this.width, this.height, 0x77000000);

        int midX = this.width / 2;
        int midY = this.height / 2;

        // Título
        graphics.drawCenteredString(this.font, Component.literal("Customização de Aparência"), midX, midY - 120, 0xFFFFFF);

        // Mostrar raça selecionada
        graphics.drawCenteredString(this.font, Component.literal("Raça: " + races.get(raceIndex).getDisplayName()), midX, midY - 80, 0xDDDDDD);

        // Mostrar olhos
        graphics.drawCenteredString(this.font, Component.literal("Olhos: " + (eyesIndex + 1)), midX, midY - 60, 0xDDDDDD);

        // Desenhar menu base (256x200)
        int menuW = 256, menuH = 200;
        int menuX = midX - menuW / 2;
        int menuY = midY - menuH / 2;

        ResourceLocation menuTex = new ResourceLocation("dragonblockinfinity", "textures/gui/menus/menu_base.png");
        graphics.blit(menuTex, menuX, menuY, 0, 0, menuW, menuH, menuW, menuH);

        // Área de preview no lado esquerdo do menu (maior)
        previewW = 96; previewH = 128;
        previewX = menuX + 12;
        previewY = menuY + 24;

        // Desenhar fundo do preview
        graphics.fill(previewX - 4, previewY - 4, previewX + previewW + 4, previewY + previewH + 4, 0xFF1E1E1E);
        // Desenhar borda sutil
        graphics.fill(previewX - 3, previewY - 3, previewX + previewW + 3, previewY - 2, 0x80FFFFFF);
        graphics.fill(previewX - 3, previewY + previewH + 2, previewX + previewW + 3, previewY + previewH + 3, 0x80FFFFFF);

        // Usar renderizador existente para desenhar modelo (body + skin)
        Race3DRenderer.renderRaceModel(graphics, previewX, previewY, previewW, previewH, races.get(raceIndex), modelYaw, 0f);

        // Desenhar botão de cor (preview) acima do menu
        int color = CustomizationData.getSelectedColor();
        graphics.fill(colorBtnX, colorBtnY, colorBtnX + colorBtnW, colorBtnY + colorBtnH, color);

        // Desenhar setas usando as PNGs (tamanho reduzido)
        ResourceLocation leftTex = new ResourceLocation("dragonblockinfinity", "textures/gui/buttoes/seta_left.png");
        ResourceLocation rightTex = new ResourceLocation("dragonblockinfinity", "textures/gui/buttoes/seta_right.png");
        // Posicionar setas/controles no lado direito do menu (vertical)
        int arrowRightX = menuX + menuW - 32;
        int arrowRightY = menuY + 30;
        int arrowLeftX = arrowRightX;
        int arrowLeftY = arrowRightY + 16;
        graphics.blit(leftTex, arrowLeftX, arrowLeftY, 0, 0, 12, 12, 12, 12);
        graphics.blit(rightTex, arrowRightX, arrowRightY, 0, 0, 12, 12, 12, 12);

        // Desenhar botões de troca de raça (miniaturas) ao lado direito (pequenas)
        int thumbX = menuX + menuW - 84;
        int thumbY = menuY + 24;
        int thumbW = 32, thumbH = 32;
        for (int i = 0; i < races.size(); i++) {
            int ty = thumbY + i * (thumbH + 6);
            // fundo da miniatura
            graphics.fill(thumbX - 2, ty - 2, thumbX + thumbW + 2, ty + thumbH + 2, i == raceIndex ? 0xFF3A7BD5 : 0xFF2A2A2A);
            Race3DRenderer.renderRaceTexture(graphics, thumbX, ty, thumbW, thumbH, races.get(i));
        }

        super.render(graphics, mouseX, mouseY, partialTicks);
    }

    @Override
    public void onClose() {
        Minecraft.getInstance().setScreen(null);
    }
}
=== src/main/java/com/dragonblockinfinity/fightstyle/Warrior.java ===
package com.dragonblockinfinity.fightstyle;

/**
 * Estilo Guerreiro
 * Focado em força e resistência corporal
 * 
 * Stats Base:
 * - Str: 14 (muito alto)
 * - Con: 13 (alto)
 * - Dex: 10 (médio)
 * - Will: 9 (baixo)
 * - Spi: 8 (muito baixo)
 * - Mnd: 9 (baixo)
 * 
 * Multiplicadores:
 * - Str: 2.2x (bônus máximo)
 * - Con: 2.0x (bônus máximo)
 * - Dex: 1.2x
 * - Mnd: 0.8x (penalidade)
 * - Will: 0.8x (penalidade)
 * - Spi: 0.5x (penalidade máxima)
 */
public class Warrior implements IFightStyle {
    
    // Stats base
    private static final int BASE_STR = 14;
    private static final int BASE_CON = 13;
    private static final int BASE_DEX = 10;
    private static final int BASE_WILL = 9;
    private static final int BASE_SPI = 8;
    private static final int BASE_MND = 9;
    
    // Multiplicadores
    private static final double STR_MULT = 2.2;
    private static final double CON_MULT = 2.0;
    private static final double DEX_MULT = 1.2;
    private static final double WILL_MULT = 0.8;
    private static final double SPI_MULT = 0.5;
    private static final double MND_MULT = 0.8;
    
    @Override
    public double getStrengthMultiplier() {
        return STR_MULT;
    }
    
    @Override
    public double getConstitutionMultiplier() {
        return CON_MULT;
    }
    
    @Override
    public double getDexterityMultiplier() {
        return DEX_MULT;
    }
    
    @Override
    public double getWillMultiplier() {
        return WILL_MULT;
    }
    
    @Override
    public double getSpiritMultiplier() {
        return SPI_MULT;
    }
    
    @Override
    public double getMindMultiplier() {
        return MND_MULT;
    }
    
    @Override
    public int getBaseStrength() {
        return BASE_STR;
    }
    
    @Override
    public int getBaseConstitution() {
        return BASE_CON;
    }
    
    @Override
    public int getBaseDexterity() {
        return BASE_DEX;
    }
    
    @Override
    public int getBaseWillpower() {
        return BASE_WILL;
    }
    
    @Override
    public int getBaseSpirit() {
        return BASE_SPI;
    }
    
    @Override
    public int getBaseMind() {
        return BASE_MND;
    }
    
    @Override
    public String getStyleName() {
        return "Guerreiro";
    }
    
    @Override
    public String getStyleDescription() {
        return "Focado em força e resistência corporal. Excelente em combate corpo a corpo mas fraco em Ki.";
    }
    
    @Override
    public int calculateBP(int str, int con, int dex, int will, int spi, int mnd) {
        return (int)(
            (str * STR_MULT) +
            (con * CON_MULT) +
            (dex * DEX_MULT) +
            (will * WILL_MULT) +
            (spi * SPI_MULT) +
            (mnd * MND_MULT)
        );
    }
    
    @Override
    public String toString() {
        return "Warrior{" +
                "Stats Base: Str=" + BASE_STR +
                ", Con=" + BASE_CON +
                ", Dex=" + BASE_DEX +
                ", Will=" + BASE_WILL +
                ", Spi=" + BASE_SPI +
                ", Mnd=" + BASE_MND +
                "\nMultiplicadores: Str=" + STR_MULT +
                ", Con=" + CON_MULT +
                ", Dex=" + DEX_MULT +
                ", Will=" + WILL_MULT +
                ", Spi=" + SPI_MULT +
                ", Mnd=" + MND_MULT +
                '}';
    }
}
=== src/main/java/com/dragonblockinfinity/fightstyle/Spiritualist.java ===
package com.dragonblockinfinity.fightstyle;

/**
 * Estilo Espiritualista
 * Focado em Ki e ataques mágicos
 * 
 * Stats Base:
 * - Str: 8 (baixo)
 * - Con: 9 (baixo)
 * - Dex: 10 (médio)
 * - Will: 13 (alto)
 * - Spi: 14 (muito alto)
 * - Mnd: 11 (acima da média)
 * 
 * Multiplicadores:
 * - Spi: 2.2x (bônus máximo)
 * - Will: 2.0x (bônus máximo)
 * - Dex: 1.2x
 * - Mnd: 1.0x
 * - Con: 0.8x (penalidade)
 * - Str: 0.5x (penalidade máxima)
 */
public class Spiritualist implements IFightStyle {
    
    // Stats base
    private static final int BASE_STR = 8;
    private static final int BASE_CON = 9;
    private static final int BASE_DEX = 10;
    private static final int BASE_WILL = 13;
    private static final int BASE_SPI = 14;
    private static final int BASE_MND = 11;
    
    // Multiplicadores
    private static final double STR_MULT = 0.5;
    private static final double CON_MULT = 0.8;
    private static final double DEX_MULT = 1.2;
    private static final double WILL_MULT = 2.0;
    private static final double SPI_MULT = 2.2;
    private static final double MND_MULT = 1.0;
    
    @Override
    public double getStrengthMultiplier() {
        return STR_MULT;
    }
    
    @Override
    public double getConstitutionMultiplier() {
        return CON_MULT;
    }
    
    @Override
    public double getDexterityMultiplier() {
        return DEX_MULT;
    }
    
    @Override
    public double getWillMultiplier() {
        return WILL_MULT;
    }
    
    @Override
    public double getSpiritMultiplier() {
        return SPI_MULT;
    }
    
    @Override
    public double getMindMultiplier() {
        return MND_MULT;
    }
    
    @Override
    public int getBaseStrength() {
        return BASE_STR;
    }
    
    @Override
    public int getBaseConstitution() {
        return BASE_CON;
    }
    
    @Override
    public int getBaseDexterity() {
        return BASE_DEX;
    }
    
    @Override
    public int getBaseWillpower() {
        return BASE_WILL;
    }
    
    @Override
    public int getBaseSpirit() {
        return BASE_SPI;
    }
    
    @Override
    public int getBaseMind() {
        return BASE_MND;
    }
    
    @Override
    public String getStyleName() {
        return "Espiritualista";
    }
    
    @Override
    public String getStyleDescription() {
        return "Focado em Ki e ataques mágicos. Excelente em ofensiva mágica mas fraco em combate corpo a corpo.";
    }
    
    @Override
    public int calculateBP(int str, int con, int dex, int will, int spi, int mnd) {
        return (int)(
            (str * STR_MULT) +
            (con * CON_MULT) +
            (dex * DEX_MULT) +
            (will * WILL_MULT) +
            (spi * SPI_MULT) +
            (mnd * MND_MULT)
        );
    }
    
    @Override
    public String toString() {
        return "Spiritualist{" +
                "Stats Base: Str=" + BASE_STR +
                ", Con=" + BASE_CON +
                ", Dex=" + BASE_DEX +
                ", Will=" + BASE_WILL +
                ", Spi=" + BASE_SPI +
                ", Mnd=" + BASE_MND +
                "\nMultiplicadores: Str=" + STR_MULT +
                ", Con=" + CON_MULT +
                ", Dex=" + DEX_MULT +
                ", Will=" + WILL_MULT +
                ", Spi=" + SPI_MULT +
                ", Mnd=" + MND_MULT +
                '}';
    }
}
=== src/main/java/com/dragonblockinfinity/fightstyle/MartialArts.java ===
package com.dragonblockinfinity.fightstyle;

/**
 * Estilo Artes Marciais
 * Equilibrado em todos os aspectos
 * 
 * Stats Base:
 * - Str: 11 (médio-alto)
 * - Con: 11 (médio-alto)
 * - Dex: 12 (médio-alto)
 * - Will: 11 (médio-alto)
 * - Spi: 11 (médio-alto)
 * - Mnd: 11 (médio-alto)
 * 
 * Multiplicadores:
 * - Str: 1.8x (bônus equilibrado)
 * - Con: 1.8x (bônus equilibrado)
 * - Dex: 1.8x (bônus equilibrado)
 * - Will: 1.2x (bônus pequeno)
 * - Spi: 1.2x (bônus pequeno)
 * - Mnd: 1.0x (neutro)
 */
public class MartialArts implements IFightStyle {
    
    // Stats base
    private static final int BASE_STR = 11;
    private static final int BASE_CON = 11;
    private static final int BASE_DEX = 12;
    private static final int BASE_WILL = 11;
    private static final int BASE_SPI = 11;
    private static final int BASE_MND = 11;
    
    // Multiplicadores
    private static final double STR_MULT = 1.8;
    private static final double CON_MULT = 1.8;
    private static final double DEX_MULT = 1.8;
    private static final double WILL_MULT = 1.2;
    private static final double SPI_MULT = 1.2;
    private static final double MND_MULT = 1.0;
    
    @Override
    public double getStrengthMultiplier() {
        return STR_MULT;
    }
    
    @Override
    public double getConstitutionMultiplier() {
        return CON_MULT;
    }
    
    @Override
    public double getDexterityMultiplier() {
        return DEX_MULT;
    }
    
    @Override
    public double getWillMultiplier() {
        return WILL_MULT;
    }
    
    @Override
    public double getSpiritMultiplier() {
        return SPI_MULT;
    }
    
    @Override
    public double getMindMultiplier() {
        return MND_MULT;
    }
    
    @Override
    public int getBaseStrength() {
        return BASE_STR;
    }
    
    @Override
    public int getBaseConstitution() {
        return BASE_CON;
    }
    
    @Override
    public int getBaseDexterity() {
        return BASE_DEX;
    }
    
    @Override
    public int getBaseWillpower() {
        return BASE_WILL;
    }
    
    @Override
    public int getBaseSpirit() {
        return BASE_SPI;
    }
    
    @Override
    public int getBaseMind() {
        return BASE_MND;
    }
    
    @Override
    public String getStyleName() {
        return "Artes Marciais";
    }
    
    @Override
    public String getStyleDescription() {
        return "Estilo equilibrado e versátil. Bom em vários aspectos mas não se destaca em nenhum.";
    }
    
    @Override
    public int calculateBP(int str, int con, int dex, int will, int spi, int mnd) {
        return (int)(
            (str * STR_MULT) +
            (con * CON_MULT) +
            (dex * DEX_MULT) +
            (will * WILL_MULT) +
            (spi * SPI_MULT) +
            (mnd * MND_MULT)
        );
    }
    
    @Override
    public String toString() {
        return "MartialArts{" +
                "Stats Base: Str=" + BASE_STR +
                ", Con=" + BASE_CON +
                ", Dex=" + BASE_DEX +
                ", Will=" + BASE_WILL +
                ", Spi=" + BASE_SPI +
                ", Mnd=" + BASE_MND +
                "\nMultiplicadores: Str=" + STR_MULT +
                ", Con=" + CON_MULT +
                ", Dex=" + DEX_MULT +
                ", Will=" + WILL_MULT +
                ", Spi=" + SPI_MULT +
                ", Mnd=" + MND_MULT +
                '}';
    }
}
=== src/main/java/com/dragonblockinfinity/fightstyle/IFightStyle.java ===
package com.dragonblockinfinity.fightstyle;

/**
 * Interface base para todos os estilos de luta
 * Define os multiplicadores e stats base de cada estilo
 */
public interface IFightStyle {
    
    /**
     * Retorna o multiplicador de Força (Str)
     */
    double getStrengthMultiplier();
    
    /**
     * Retorna o multiplicador de Constituição (Con)
     */
    double getConstitutionMultiplier();
    
    /**
     * Retorna o multiplicador de Destreza (Dex)
     */
    double getDexterityMultiplier();
    
    /**
     * Retorna o multiplicador de Vontade (Will)
     */
    double getWillMultiplier();
    
    /**
     * Retorna o multiplicador de Espírito (Spi)
     */
    double getSpiritMultiplier();
    
    /**
     * Retorna o multiplicador de Mente (Mnd)
     */
    double getMindMultiplier();
    
    /**
     * Retorna o stat base de Força
     */
    int getBaseStrength();
    
    /**
     * Retorna o stat base de Constituição
     */
    int getBaseConstitution();
    
    /**
     * Retorna o stat base de Destreza
     */
    int getBaseDexterity();
    
    /**
     * Retorna o stat base de Vontade
     */
    int getBaseWillpower();
    
    /**
     * Retorna o stat base de Espírito
     */
    int getBaseSpirit();
    
    /**
     * Retorna o stat base de Mente
     */
    int getBaseMind();
    
    /**
     * Retorna o nome do estilo
     */
    String getStyleName();
    
    /**
     * Retorna a descrição do estilo
     */
    String getStyleDescription();
    
    /**
     * Calcula BP baseado neste estilo
     */
    int calculateBP(int str, int con, int dex, int will, int spi, int mnd);
}
=== src/main/java/com/dragonblockinfinity/fightstyle/FightStyleEnum.java ===
package com.dragonblockinfinity.fightstyle;

/**
 * Enum para registrar todos os estilos de luta disponíveis
 */
public enum FightStyleEnum {
    SPIRITUALIST("Espiritualista", "Focado em Ki e ataques mágicos"),
    WARRIOR("Guerreiro", "Focado em força e resistência corporal"),
    MARTIAL_ARTS("Artes Marciais", "Estilo equilibrado e versátil");
    
    private final String displayName;
    private final String description;
    
    FightStyleEnum(String displayName, String description) {
        this.displayName = displayName;
        this.description = description;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    public String getDescription() {
        return description;
    }
}
=== src/main/java/com/dragonblockinfinity/fightstyle/FightStyleRegistry.java ===
package com.dragonblockinfinity.fightstyle;

import java.util.HashMap;
import java.util.Map;

/**
 * Registro central de todos os estilos de luta disponíveis
 * Gerencia instâncias e acesso aos estilos
 */
public class FightStyleRegistry {
    
    private static final Map<FightStyleEnum, IFightStyle> REGISTRY = new HashMap<>();
    
    // Instâncias dos estilos
    private static final Spiritualist SPIRITUALIST_INSTANCE = new Spiritualist();
    private static final Warrior WARRIOR_INSTANCE = new Warrior();
    private static final MartialArts MARTIAL_ARTS_INSTANCE = new MartialArts();
    
    static {
        // Registra todos os estilos
        REGISTRY.put(FightStyleEnum.SPIRITUALIST, SPIRITUALIST_INSTANCE);
        REGISTRY.put(FightStyleEnum.WARRIOR, WARRIOR_INSTANCE);
        REGISTRY.put(FightStyleEnum.MARTIAL_ARTS, MARTIAL_ARTS_INSTANCE);
    }
    
    /**
     * Retorna a instância do estilo baseado no enum
     */
    public static IFightStyle getStyle(FightStyleEnum style) {
        IFightStyle fightStyle = REGISTRY.get(style);
        if (fightStyle == null) {
            throw new IllegalArgumentException("Estilo de luta não registrado: " + style);
        }
        return fightStyle;
    }
    
    /**
     * Retorna o Spiritualist
     */
    public static IFightStyle getSpiritualista() {
        return SPIRITUALIST_INSTANCE;
    }
    
    /**
     * Retorna o Warrior
     */
    public static IFightStyle getWarrior() {
        return WARRIOR_INSTANCE;
    }
    
    /**
     * Retorna o Martial Arts
     */
    public static IFightStyle getMartialArts() {
        return MARTIAL_ARTS_INSTANCE;
    }
    
    /**
     * Retorna todos os estilos registrados
     */
    public static IFightStyle[] getAllStyles() {
        return REGISTRY.values().toArray(new IFightStyle[0]);
    }
    
    /**
     * Retorna informações sobre todos os estilos
     */
    public static String getAllStylesInfo() {
        StringBuilder sb = new StringBuilder("=== ESTILOS DE LUTA DISPONÍVEIS ===\n\n");
        
        for (FightStyleEnum enum_style : FightStyleEnum.values()) {
            IFightStyle style = getStyle(enum_style);
            
            sb.append("【 ").append(style.getStyleName().toUpperCase()).append(" 】\n");
            sb.append("Descrição: ").append(style.getStyleDescription()).append("\n");
            sb.append("Stats Base:\n");
            sb.append("  Str: ").append(style.getBaseStrength())
                    .append(" (×").append(style.getStrengthMultiplier()).append(")\n");
            sb.append("  Con: ").append(style.getBaseConstitution())
                    .append(" (×").append(style.getConstitutionMultiplier()).append(")\n");
            sb.append("  Dex: ").append(style.getBaseDexterity())
                    .append(" (×").append(style.getDexterityMultiplier()).append(")\n");
            sb.append("  Will: ").append(style.getBaseWillpower())
                    .append(" (×").append(style.getWillMultiplier()).append(")\n");
            sb.append("  Spi: ").append(style.getBaseSpirit())
                    .append(" (×").append(style.getSpiritMultiplier()).append(")\n");
            sb.append("  Mnd: ").append(style.getBaseMind())
                    .append(" (×").append(style.getMindMultiplier()).append(")\n\n");
        }
        
        return sb.toString();
    }
    
    /**
     * Retorna info detalhada de um estilo específico
     */
    public static String getStyleInfo(FightStyleEnum styleEnum) {
        IFightStyle style = getStyle(styleEnum);
        
        return "=== " + style.getStyleName().toUpperCase() + " ===\n" +
                "Descrição: " + style.getStyleDescription() + "\n\n" +
                "Stats Base:\n" +
                "  Força (Str): " + style.getBaseStrength() + "\n" +
                "  Constituição (Con): " + style.getBaseConstitution() + "\n" +
                "  Destreza (Dex): " + style.getBaseDexterity() + "\n" +
                "  Vontade (Will): " + style.getBaseWillpower() + "\n" +
                "  Espírito (Spi): " + style.getBaseSpirit() + "\n" +
                "  Mente (Mnd): " + style.getBaseMind() + "\n\n" +
                "Multiplicadores de Stats:\n" +
                "  Str: ×" + style.getStrengthMultiplier() + "\n" +
                "  Con: ×" + style.getConstitutionMultiplier() + "\n" +
                "  Dex: ×" + style.getDexterityMultiplier() + "\n" +
                "  Will: ×" + style.getWillMultiplier() + "\n" +
                "  Spi: ×" + style.getSpiritMultiplier() + "\n" +
                "  Mnd: ×" + style.getMindMultiplier();
    }
}
=== src/main/java/com/dragonblockinfinity/util/Constants.java ===
package com.dragonblockinfinity.util;

/**
 * Classe com constantes do projeto Dragon Block Infinity
 */
public class Constants {
    public static final String MOD_ID = "dragonblockinfinity";
    public static final String MOD_NAME = "Dragon Block Infinity";
    public static final String MOD_VERSION = "1.0.0";
}
=== src/main/java/com/dragonblockinfinity/race/Namekian.java ===
package com.dragonblockinfinity.race;

import com.dragonblockinfinity.fightstyle.FightStyleEnum;

/**
 * Raça Namekiano
 * Místicos e regenerativos com grande afinidade com Ki
 * 
 * Stats Base: Espírito alto, Vontade alta
 * Ki Máximo: 4500 base
 * Multiplicador de Ki: 1.8x
 * Estilo de Luta: Spiritualist (Ki e magia)
 */
public class Namekian implements IRace {
    
    private static final int MAX_KI_BASE = 4500;
    private static final double KI_MULTIPLIER = 1.8;
    private static final FightStyleEnum FIGHT_STYLE = FightStyleEnum.SPIRITUALIST;
    
    // Stats base
    private static final int BASE_STR = 9;
    private static final int BASE_CON = 10;
    private static final int BASE_DEX = 10;
    private static final int BASE_WILL = 14;
    private static final int BASE_SPI = 15;
    private static final int BASE_MND = 12;
    
    @Override
    public int getMaxKiBase() {
        return MAX_KI_BASE;
    }
    
    @Override
    public double getKiMultiplier() {
        return KI_MULTIPLIER;
    }
    
    @Override
    public FightStyleEnum getPreferredFightStyle() {
        return FIGHT_STYLE;
    }
    
    @Override
    public int getBaseStrength() {
        return BASE_STR;
    }
    
    @Override
    public int getBaseConstitution() {
        return BASE_CON;
    }
    
    @Override
    public int getBaseDexterity() {
        return BASE_DEX;
    }
    
    @Override
    public int getBaseWillpower() {
        return BASE_WILL;
    }
    
    @Override
    public int getBaseSpirit() {
        return BASE_SPI;
    }
    
    @Override
    public int getBaseMind() {
        return BASE_MND;
    }
    
    @Override
    public String getRaceName() {
        return "Namekiano";
    }
    
    @Override
    public String getRaceDescription() {
        return "Místicos e regenerativos com grande afinidade com Ki e magia";
    }
    
    @Override
    public int calculateMaxKi() {
        return (int)(MAX_KI_BASE * KI_MULTIPLIER);
    }
    
    @Override
    public String toString() {
        return "Namekian{" +
                "Ki=" + calculateMaxKi() +
                ", Estilo=" + FIGHT_STYLE.getDisplayName() +
                ", Stats=[Str=" + BASE_STR +
                ", Con=" + BASE_CON +
                ", Dex=" + BASE_DEX +
                ", Will=" + BASE_WILL +
                ", Spi=" + BASE_SPI +
                ", Mnd=" + BASE_MND +
                "]}";
    }
}
=== src/main/java/com/dragonblockinfinity/race/IRace.java ===
package com.dragonblockinfinity.race;

import com.dragonblockinfinity.fightstyle.FightStyleEnum;

/**
 * Interface base para todas as raças
 */
public interface IRace {
    
    /**
     * Retorna o Ki máximo base da raça
     */
    int getMaxKiBase();
    
    /**
     * Retorna o multiplicador de Ki (afeta Ki máximo)
     */
    double getKiMultiplier();
    
    /**
     * Retorna o estilo de luta preferido da raça
     */
    FightStyleEnum getPreferredFightStyle();
    
    /**
     * Retorna stat base de Força
     */
    int getBaseStrength();
    
    /**
     * Retorna stat base de Constituição
     */
    int getBaseConstitution();
    
    /**
     * Retorna stat base de Destreza
     */
    int getBaseDexterity();
    
    /**
     * Retorna stat base de Vontade
     */
    int getBaseWillpower();
    
    /**
     * Retorna stat base de Espírito
     */
    int getBaseSpirit();
    
    /**
     * Retorna stat base de Mente
     */
    int getBaseMind();
    
    /**
     * Retorna o nome da raça
     */
    String getRaceName();
    
    /**
     * Retorna a descrição da raça
     */
    String getRaceDescription();
    
    /**
     * Calcula Ki máximo total da raça
     */
    int calculateMaxKi();
}
=== src/main/java/com/dragonblockinfinity/race/RaceEnum.java ===
package com.dragonblockinfinity.race;

/**
 * Enum para registrar todas as raças disponíveis
 * Saiyan, Human, Half-Saiyan e Arconsian estão registradas
 * Android, Majin e Namekian serão adicionadas quando as texturas forem criadas
 */
public enum RaceEnum {
    SAIYAN("Saiyajin", "Guerreiros poderosos com grande potencial"),
    HUMAN("Humano", "Adaptável e determinado"),
    HALF("Metade-Saiyajin", "Híbrido com potencial extraordinário"),
    ARCONSIAN("Arconsiano", "Guerreiro galáctico frio e poderoso"),
    
    // TODO: Adicionar quando as texturas forem criadas
    // NAMEKIAN("Namekiano", "Místicos e regenerativos"),
    // ANDROID("Android", "Tecnológico e perfeito"),
    // MAJIN("Majin", "Mágico e poderoso");
    ;
    
    private final String displayName;
    private final String description;
    
    RaceEnum(String displayName, String description) {
        this.displayName = displayName;
        this.description = description;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    public String getDescription() {
        return description;
    }
}
=== src/main/java/com/dragonblockinfinity/race/Majin.java ===
package com.dragonblockinfinity.race;

import com.dragonblockinfinity.fightstyle.FightStyleEnum;

/**
 * Raça Majin
 * Mágica e poderosa com grande versatilidade
 * 
 * Stats Base: Vontade alta, Constituição alta
 * Ki Máximo: 5500 base
 * Multiplicador de Ki: 1.9x
 * Estilo de Luta: Spiritualist (magia)
 */
public class Majin implements IRace {
    
    private static final int MAX_KI_BASE = 5500;
    private static final double KI_MULTIPLIER = 1.9;
    private static final FightStyleEnum FIGHT_STYLE = FightStyleEnum.SPIRITUALIST;
    
    // Stats base
    private static final int BASE_STR = 12;
    private static final int BASE_CON = 14;
    private static final int BASE_DEX = 11;
    private static final int BASE_WILL = 15;
    private static final int BASE_SPI = 13;
    private static final int BASE_MND = 10;
    
    @Override
    public int getMaxKiBase() {
        return MAX_KI_BASE;
    }
    
    @Override
    public double getKiMultiplier() {
        return KI_MULTIPLIER;
    }
    
    @Override
    public FightStyleEnum getPreferredFightStyle() {
        return FIGHT_STYLE;
    }
    
    @Override
    public int getBaseStrength() {
        return BASE_STR;
    }
    
    @Override
    public int getBaseConstitution() {
        return BASE_CON;
    }
    
    @Override
    public int getBaseDexterity() {
        return BASE_DEX;
    }
    
    @Override
    public int getBaseWillpower() {
        return BASE_WILL;
    }
    
    @Override
    public int getBaseSpirit() {
        return BASE_SPI;
    }
    
    @Override
    public int getBaseMind() {
        return BASE_MND;
    }
    
    @Override
    public String getRaceName() {
        return "Majin";
    }
    
    @Override
    public String getRaceDescription() {
        return "Mágica e poderosa com grande versatilidade e poder mágico";
    }
    
    @Override
    public int calculateMaxKi() {
        return (int)(MAX_KI_BASE * KI_MULTIPLIER);
    }
    
    @Override
    public String toString() {
        return "Majin{" +
                "Ki=" + calculateMaxKi() +
                ", Estilo=" + FIGHT_STYLE.getDisplayName() +
                ", Stats=[Str=" + BASE_STR +
                ", Con=" + BASE_CON +
                ", Dex=" + BASE_DEX +
                ", Will=" + BASE_WILL +
                ", Spi=" + BASE_SPI +
                ", Mnd=" + BASE_MND +
                "]}";
    }
}
=== src/main/java/com/dragonblockinfinity/race/HalfSaiyan.java ===
package com.dragonblockinfinity.race;

import com.dragonblockinfinity.fightstyle.FightStyleEnum;
import com.dragonblockinfinity.status.*;

/**
 * Raça Half-Saiyan (metade-saiyajin)
 * Híbrido entre Saiyajim e Humano com potencial extraordinário
 * Força: Ki equilibrado, stats balanceados
 */
public class HalfSaiyan implements IRace {
    
    @Override
    public int getMaxKiBase() {
        // Entre Human (3000) e Saiyan (5000)
        return 4000;
    }
    
    @Override
    public double getKiMultiplier() {
        // Multiplicador intermediário
        return 1.4;
    }
    
    @Override
    public FightStyleEnum getPreferredFightStyle() {
        // Half-Saiyan combina bem com Martial Arts
        return FightStyleEnum.MARTIAL_ARTS;
    }
    
    @Override
    public int getBaseStrength() {
        // Força intermediária
        return 12;
    }
    
    @Override
    public int getBaseConstitution() {
        // Resistência equilibrada
        return 11;
    }
    
    @Override
    public int getBaseDexterity() {
        // Boa destreza, herança humana
        return 11;
    }
    
    @Override
    public int getBaseWillpower() {
        // Ki balance normal
        return 10;
    }
    
    @Override
    public int getBaseSpirit() {
        // Espírito moderado
        return 11;
    }
    
    @Override
    public int getBaseMind() {
        // Mente equilibrada
        return 10;
    }
    
    @Override
    public String getRaceName() {
        return "Half-Saiyajin";
    }
    
    @Override
    public String getRaceDescription() {
        return "Híbrido com potencial extraordinário";
    }
    
    @Override
    public int calculateMaxKi() {
        return (int) (getMaxKiBase() * getKiMultiplier());
    }
}
=== src/main/java/com/dragonblockinfinity/race/Saiyan.java ===
package com.dragonblockinfinity.race;

import com.dragonblockinfinity.fightstyle.FightStyleEnum;

/**
 * Raça Saiyajin
 * Guerreiros natos com grande potencial de poder
 * 
 * Stats Base: Força alta, Constituição alta
 * Ki Máximo: 5000 base
 * Multiplicador de Ki: 1.5x
 * Estilo de Luta: Warrior (corpo a corpo)
 */
public class Saiyan implements IRace {
    
    private static final int MAX_KI_BASE = 5000;
    private static final double KI_MULTIPLIER = 1.5;
    private static final FightStyleEnum FIGHT_STYLE = FightStyleEnum.WARRIOR;
    
    // Stats base
    private static final int BASE_STR = 15;
    private static final int BASE_CON = 14;
    private static final int BASE_DEX = 12;
    private static final int BASE_WILL = 10;
    private static final int BASE_SPI = 10;
    private static final int BASE_MND = 8;
    
    @Override
    public int getMaxKiBase() {
        return MAX_KI_BASE;
    }
    
    @Override
    public double getKiMultiplier() {
        return KI_MULTIPLIER;
    }
    
    @Override
    public FightStyleEnum getPreferredFightStyle() {
        return FIGHT_STYLE;
    }
    
    @Override
    public int getBaseStrength() {
        return BASE_STR;
    }
    
    @Override
    public int getBaseConstitution() {
        return BASE_CON;
    }
    
    @Override
    public int getBaseDexterity() {
        return BASE_DEX;
    }
    
    @Override
    public int getBaseWillpower() {
        return BASE_WILL;
    }
    
    @Override
    public int getBaseSpirit() {
        return BASE_SPI;
    }
    
    @Override
    public int getBaseMind() {
        return BASE_MND;
    }
    
    @Override
    public String getRaceName() {
        return "Saiyajin";
    }
    
    @Override
    public String getRaceDescription() {
        return "Guerreiros natos com grande potencial de poder e transformações";
    }
    
    @Override
    public int calculateMaxKi() {
        return (int)(MAX_KI_BASE * KI_MULTIPLIER);
    }
    
    @Override
    public String toString() {
        return "Saiyan{" +
                "Ki=" + calculateMaxKi() +
                ", Estilo=" + FIGHT_STYLE.getDisplayName() +
                ", Stats=[Str=" + BASE_STR +
                ", Con=" + BASE_CON +
                ", Dex=" + BASE_DEX +
                ", Will=" + BASE_WILL +
                ", Spi=" + BASE_SPI +
                ", Mnd=" + BASE_MND +
                "]}";
    }
}
=== src/main/java/com/dragonblockinfinity/race/Android.java ===
package com.dragonblockinfinity.race;

import com.dragonblockinfinity.fightstyle.FightStyleEnum;

/**
 * Raça Android
 * Tecnológico e perfeito com grande poder constante
 * 
 * Stats Base: Força alta, Destreza alta
 * Ki Máximo: 6000 base (maior de todos!)
 * Multiplicador de Ki: 2.0x
 * Estilo de Luta: Warrior (combate direto)
 */
public class Android implements IRace {
    
    private static final int MAX_KI_BASE = 6000;
    private static final double KI_MULTIPLIER = 2.0;
    private static final FightStyleEnum FIGHT_STYLE = FightStyleEnum.WARRIOR;
    
    // Stats base
    private static final int BASE_STR = 16;
    private static final int BASE_CON = 13;
    private static final int BASE_DEX = 14;
    private static final int BASE_WILL = 9;
    private static final int BASE_SPI = 8;
    private static final int BASE_MND = 11;
    
    @Override
    public int getMaxKiBase() {
        return MAX_KI_BASE;
    }
    
    @Override
    public double getKiMultiplier() {
        return KI_MULTIPLIER;
    }
    
    @Override
    public FightStyleEnum getPreferredFightStyle() {
        return FIGHT_STYLE;
    }
    
    @Override
    public int getBaseStrength() {
        return BASE_STR;
    }
    
    @Override
    public int getBaseConstitution() {
        return BASE_CON;
    }
    
    @Override
    public int getBaseDexterity() {
        return BASE_DEX;
    }
    
    @Override
    public int getBaseWillpower() {
        return BASE_WILL;
    }
    
    @Override
    public int getBaseSpirit() {
        return BASE_SPI;
    }
    
    @Override
    public int getBaseMind() {
        return BASE_MND;
    }
    
    @Override
    public String getRaceName() {
        return "Android";
    }
    
    @Override
    public String getRaceDescription() {
        return "Tecnológico e perfeito com poder constante e altíssimo Ki máximo";
    }
    
    @Override
    public int calculateMaxKi() {
        return (int)(MAX_KI_BASE * KI_MULTIPLIER);
    }
    
    @Override
    public String toString() {
        return "Android{" +
                "Ki=" + calculateMaxKi() +
                ", Estilo=" + FIGHT_STYLE.getDisplayName() +
                ", Stats=[Str=" + BASE_STR +
                ", Con=" + BASE_CON +
                ", Dex=" + BASE_DEX +
                ", Will=" + BASE_WILL +
                ", Spi=" + BASE_SPI +
                ", Mnd=" + BASE_MND +
                "]}";
    }
}
=== src/main/java/com/dragonblockinfinity/race/Arcosian.java ===
package com.dragonblockinfinity.race;

import com.dragonblockinfinity.fightstyle.FightStyleEnum;
import com.dragonblockinfinity.status.*;

/**
 * Raça Arcosian
 * Tirano intergaláctico com poder lendário e ki colossal
 * Força: Ki muito alto, stats físicos elevados
 */
public class Arcosian implements IRace {
    
    @Override
    public int getMaxKiBase() {
        // Ki mais alto que Saiyajin
        return 6000;
    }
    
    @Override
    public double getKiMultiplier() {
        // Multiplicador de ki extremamente alto
        return 1.8;
    }
    
    @Override
    public FightStyleEnum getPreferredFightStyle() {
        // Arcosians are pure warriors
        return FightStyleEnum.WARRIOR;
    }
    
    @Override
    public int getBaseStrength() {
        // Força excepcional, rival de Saiyajin
        return 14;
    }
    
    @Override
    public int getBaseConstitution() {
        // Resistência comparável a Saiyajin
        return 13;
    }
    
    @Override
    public int getBaseDexterity() {
        // Destreza moderada, foco em poder bruto
        return 9;
    }
    
    @Override
    public int getBaseWillpower() {
        // Vontade comparável
        return 9;
    }
    
    @Override
    public int getBaseSpirit() {
        // Espírito intermediário
        return 9;
    }
    
    @Override
    public int getBaseMind() {
        // Mente moderada, tático
        return 10;
    }
    
    @Override
    public String getRaceName() {
        return "Arcosian";
    }
    
    @Override
    public String getRaceDescription() {
        return "Tirano intergaláctico com poder lendário";
    }
    
    @Override
    public int calculateMaxKi() {
        return (int) (getMaxKiBase() * getKiMultiplier());
    }
}
=== src/main/java/com/dragonblockinfinity/race/Human.java ===
package com.dragonblockinfinity.race;

import com.dragonblockinfinity.fightstyle.FightStyleEnum;

/**
 * Raça Humano
 * Adaptável e determinado, grande potencial de aprendizado
 * 
 * Stats Base: Equilibrados
 * Ki Máximo: 3000 base
 * Multiplicador de Ki: 1.0x
 * Estilo de Luta: Martial Arts (equilibrado)
 */
public class Human implements IRace {
    
    private static final int MAX_KI_BASE = 3000;
    private static final double KI_MULTIPLIER = 1.0;
    private static final FightStyleEnum FIGHT_STYLE = FightStyleEnum.MARTIAL_ARTS;
    
    // Stats base
    private static final int BASE_STR = 11;
    private static final int BASE_CON = 11;
    private static final int BASE_DEX = 11;
    private static final int BASE_WILL = 11;
    private static final int BASE_SPI = 11;
    private static final int BASE_MND = 12;
    
    @Override
    public int getMaxKiBase() {
        return MAX_KI_BASE;
    }
    
    @Override
    public double getKiMultiplier() {
        return KI_MULTIPLIER;
    }
    
    @Override
    public FightStyleEnum getPreferredFightStyle() {
        return FIGHT_STYLE;
    }
    
    @Override
    public int getBaseStrength() {
        return BASE_STR;
    }
    
    @Override
    public int getBaseConstitution() {
        return BASE_CON;
    }
    
    @Override
    public int getBaseDexterity() {
        return BASE_DEX;
    }
    
    @Override
    public int getBaseWillpower() {
        return BASE_WILL;
    }
    
    @Override
    public int getBaseSpirit() {
        return BASE_SPI;
    }
    
    @Override
    public int getBaseMind() {
        return BASE_MND;
    }
    
    @Override
    public String getRaceName() {
        return "Humano";
    }
    
    @Override
    public String getRaceDescription() {
        return "Adaptável e determinado com grande potencial de aprendizado";
    }
    
    @Override
    public int calculateMaxKi() {
        return (int)(MAX_KI_BASE * KI_MULTIPLIER);
    }
    
    @Override
    public String toString() {
        return "Human{" +
                "Ki=" + calculateMaxKi() +
                ", Estilo=" + FIGHT_STYLE.getDisplayName() +
                ", Stats=[Str=" + BASE_STR +
                ", Con=" + BASE_CON +
                ", Dex=" + BASE_DEX +
                ", Will=" + BASE_WILL +
                ", Spi=" + BASE_SPI +
                ", Mnd=" + BASE_MND +
                "]}";
    }
}
=== src/main/java/com/dragonblockinfinity/power/RaceKiTechniques.java ===
package com.dragonblockinfinity.power;

import com.dragonblockinfinity.race.RaceEnum;

/**
 * Sistema de técnicas especiais de Ki por raça
 * Cada raça tem suas próprias técnicas únicas
 */
public class RaceKiTechniques {
    
    /**
     * Técnicas de Saiyajin
     */
    public static class SaiyanTechniques {
        public static final String KAIOKEN = "kaioken"; // Aumenta força mas consome stamina
        public static final String SPIRIT_BOMB = "spirit_bomb"; // Técnica poderosa coletiva
        public static final String KAMEHAMEHA = "kamehameha"; // Raio de Ki poderoso
        
        public static int getKiCost(String technique) {
            return switch (technique) {
                case KAIOKEN -> 15; // 15% de Ki
                case SPIRIT_BOMB -> 60; // 60% de Ki (muito caro)
                case KAMEHAMEHA -> 40; // 40% de Ki
                default -> 0;
            };
        }
        
        public static double getDamage(String technique, int kiLevel) {
            return switch (technique) {
                case KAIOKEN -> kiLevel * 1.5;
                case SPIRIT_BOMB -> kiLevel * 3.0;
                case KAMEHAMEHA -> kiLevel * 2.5;
                default -> 0;
            };
        }
    }
    
    /**
     * Técnicas de Arcosian
     */
    public static class ArcosianTechniques {
        public static final String DEATH_BEAM = "death_beam"; // Raio mortal precisso
        public static final String FINAL_FLASH = "final_flash"; // Explosão final poderosa
        public static final String NOVA_STRIKE = "nova_strike"; // Ataque explosivo
        
        public static int getKiCost(String technique) {
            return switch (technique) {
                case DEATH_BEAM -> 25; // 25% de Ki
                case FINAL_FLASH -> 70; // 70% de Ki (muito caro)
                case NOVA_STRIKE -> 50; // 50% de Ki
                default -> 0;
            };
        }
        
        public static double getDamage(String technique, int kiLevel) {
            return switch (technique) {
                case DEATH_BEAM -> kiLevel * 2.0; // Muito preciso e letal
                case FINAL_FLASH -> kiLevel * 3.2;
                case NOVA_STRIKE -> kiLevel * 2.8;
                default -> 0;
            };
        }
    }
    
    /**
     * Técnicas de Half-Saiyan
     */
    public static class HalfSaiyanTechniques {
        public static final String HYBRID_BLAST = "hybrid_blast"; // Combinação de técnicas
        public static final String POWER_SURGE = "power_surge"; // Aumento rápido de força
        public static final String ADAPTIVE_COUNTER = "adaptive_counter"; // Contra-ataque adaptável
        
        public static int getKiCost(String technique) {
            return switch (technique) {
                case HYBRID_BLAST -> 35; // 35% de Ki
                case POWER_SURGE -> 30; // 30% de Ki
                case ADAPTIVE_COUNTER -> 20; // 20% de Ki (barato)
                default -> 0;
            };
        }
        
        public static double getDamage(String technique, int kiLevel) {
            return switch (technique) {
                case HYBRID_BLAST -> kiLevel * 2.2;
                case POWER_SURGE -> kiLevel * 1.8; // Mais sobre aumento que dano imediato
                case ADAPTIVE_COUNTER -> kiLevel * 1.5;
                default -> 0;
            };
        }
    }
    
    /**
     * Técnicas de Humano
     */
    public static class HumanTechniques {
        public static final String CHARGED_SHOT = "charged_shot"; // Tiro carregado
        public static final String ENERGY_WAVE = "energy_wave"; // Onda de energia controlada
        public static final String MULTI_ATTACK = "multi_attack"; // Múltiplos ataques rápidos
        
        public static int getKiCost(String technique) {
            return switch (technique) {
                case CHARGED_SHOT -> 40; // 40% de Ki
                case ENERGY_WAVE -> 45; // 45% de Ki
                case MULTI_ATTACK -> 35; // 35% de Ki
                default -> 0;
            };
        }
        
        public static double getDamage(String technique, int kiLevel) {
            return switch (technique) {
                case CHARGED_SHOT -> kiLevel * 2.0;
                case ENERGY_WAVE -> kiLevel * 2.1;
                case MULTI_ATTACK -> kiLevel * 1.9;
                default -> 0;
            };
        }
    }
    
    /**
     * Obtém custo de Ki de uma técnica baseado na raça
     */
    public static int getTechniqueCost(RaceEnum race, String technique) {
        return switch (race) {
            case SAIYAN -> SaiyanTechniques.getKiCost(technique);
            case ARCONSIAN -> ArcosianTechniques.getKiCost(technique);
            case HALF -> HalfSaiyanTechniques.getKiCost(technique);
            case HUMAN -> HumanTechniques.getKiCost(technique);
            default -> 0;
        };
    }
    
    /**
     * Obtém dano de uma técnica baseado na raça e nível de Ki
     */
    public static double getTechniqueDamage(RaceEnum race, String technique, int kiLevel) {
        return switch (race) {
            case SAIYAN -> SaiyanTechniques.getDamage(technique, kiLevel);
            case ARCONSIAN -> ArcosianTechniques.getDamage(technique, kiLevel);
            case HALF -> HalfSaiyanTechniques.getDamage(technique, kiLevel);
            case HUMAN -> HumanTechniques.getDamage(technique, kiLevel);
            default -> 0;
        };
    }
}
=== src/main/java/com/dragonblockinfinity/power/RaceKiAbilities.java ===
package com.dragonblockinfinity.power;

import com.dragonblockinfinity.race.RaceEnum;

/**
 * Sistema de habilidades especiais de Ki por raça
 */
public class RaceKiAbilities {
    
    /**
     * Calcula o regeneração de Ki por tick baseado na raça
     */
    public static double getKiRegenPerTick(RaceEnum race) {
        return switch (race) {
            case SAIYAN -> 1.2; // Saiyajin regenera 20% mais rápido
            case HALF -> 1.1; // Half-Saiyan regenera 10% mais rápido
            case HUMAN -> 1.0; // Humano regeneração padrão
            case ARCONSIAN -> 0.95; // Arcosian regenera um pouco mais lento
            default -> 1.0;
        };
    }
    
    /**
     * Multiplica dano de Ki baseado na raça
     */
    public static double getKiDamageMultiplier(RaceEnum race) {
        return switch (race) {
            case SAIYAN -> 1.15; // Saiyajin causa 15% mais dano
            case HALF -> 1.05; // Half-Saiyan causa 5% mais dano
            case HUMAN -> 1.0; // Humano padrão
            case ARCONSIAN -> 1.25; // Arcosian causa 25% mais dano de Ki
            default -> 1.0;
        };
    }
    
    /**
     * Habilidade especial: Saiyan - pode aumentar força ao receber dano
     */
    public static double getSaiyanPowerUp(int damageReceived) {
        // Saiyajin fica mais forte quando recebe dano
        // A cada 100 de dano recebido, ganha +1% de força
        return 1.0 + (damageReceived / 100.0) * 0.01;
    }
    
    /**
     * Habilidade especial: Saiyan - Zenkai Boost após recuperação
     * Ganha 2x de aumento em stats (Str, Dex, Con) ao se recuperar de dano extremo
     */
    public static double getSaiyanZenkai(int healthPercentBefore) {
        // Zenkai ativa quando se recupera de vida muito baixa
        // Quanto mais perto da morte estava, mais forte fica
        // Máximo 2.0x multiplicador
        if (healthPercentBefore <= 10) {
            return 2.0; // 2x multiplicador para Str, Dex, Con
        } else if (healthPercentBefore <= 30) {
            return 1.5; // 1.5x se estava moderadamente machucado
        }
        return 1.0; // Sem bonus se não estava perto da morte
    }
    /**
     * Habilidade especial: Arcosian - forma final aumenta tudo
     */
    public static double getArcosianFormMultiplier(boolean finalForm) {
        return finalForm ? 1.5 : 1.0; // Forma final multiplica tudo por 1.5x
    }
    
    /**
     * Habilidade especial: Human - Ki se recupera mais rápido em combate
     */
    public static double getHumanCombatRegenBonus(boolean inCombat) {
        return inCombat ? 1.3 : 1.0; // 30% mais rápido durante combate
    }
    
    /**
     * Habilidade especial: Half-Saiyan - combinação de habilidades
     */
    public static double getHalfSaiyanAdaptability(int combatDuration) {
        // Fica mais forte conforme o tempo em combate passa
        // A cada 20 segundos, ganha +0.5% de adaptação
        return 1.0 + (combatDuration / 400.0) * 0.005;
    }
    
    /**
     * Habilidade especial: Half-Saiyan - Zenkai Boost (versão reduzida)
     * Ganha 1.5x de aumento em stats (Str, Dex, Con) ao se recuperar de dano extremo
     */
    public static double getHalfSaiyanZenkai(int healthPercentBefore) {
        // Zenkai ativa quando se recupera de vida muito baixa
        // Versão reduzida em comparação ao Saiyajin puro (1.5x vs 2.0x)
        if (healthPercentBefore <= 10) {
            return 1.5; // 1.5x multiplicador para Str, Dex, Con
        } else if (healthPercentBefore <= 30) {
            return 1.25; // 1.25x se estava moderadamente machucado
        }
        return 1.0; // Sem bonus se não estava perto da morte
    }
}
=== src/main/java/com/dragonblockinfinity/power/RaceTransformations.java ===
package com.dragonblockinfinity.power;

import com.dragonblockinfinity.race.RaceEnum;

/**
 * Sistema de transformações especiais por raça
 */
public class RaceTransformations {
    
    /**
     * Super Saiyan - transf. clássica de Saiyajin
     */
    public static class SuperSaiyan {
        public static final double STRENGTH_MULTIPLIER = 2.0;
        public static final double KI_MULTIPLIER = 2.2;
        public static final double SPEED_MULTIPLIER = 1.8;
        public static final double KI_CONSUMPTION = 2.0; // Consome 2x mais Ki
        
        public static boolean canTransform(int kiPercent) {
            return kiPercent >= 50; // Precisa de 50% de Ki
        }
    }
    
    /**
     * Golden Form - forma final de Saiyajin
     */
    public static class GoldenForm {
        public static final double STRENGTH_MULTIPLIER = 3.0;
        public static final double KI_MULTIPLIER = 4.0;
        public static final double SPEED_MULTIPLIER = 3.0;
        public static final double KI_CONSUMPTION = 4.0; // Consome 4x mais Ki
        
        public static boolean canTransform(int kiPercent) {
            return kiPercent >= 75; // Precisa de 75% de Ki
        }
    }
    
    /**
     * Arcosian Final Form - forma final do Arcosian
     */
    public static class ArcosianFinalForm {
        public static final double STRENGTH_MULTIPLIER = 2.5;
        public static final double KI_MULTIPLIER = 3.0;
        public static final double SPEED_MULTIPLIER = 2.2;
        public static final double KI_CONSUMPTION = 3.0;
        
        public static boolean canTransform(int kiPercent) {
            return kiPercent >= 60;
        }
    }
    
    /**
     * Half-Saiyan Hybrid Mode - combinação de poderes
     */
    public static class HybridMode {
        public static final double STRENGTH_MULTIPLIER = 1.6;
        public static final double KI_MULTIPLIER = 1.8;
        public static final double SPEED_MULTIPLIER = 1.7;
        public static final double KI_CONSUMPTION = 1.5;
        
        public static boolean canTransform(int kiPercent) {
            return kiPercent >= 40;
        }
    }
    
    /**
     * Human Zenkai Boost - Humano fica mais forte após se recuperar de quase morte
     */
    public static class ZenkaiBoost {
        public static final double STRENGTH_MULTIPLIER = 1.3;
        public static final double KI_MULTIPLIER = 1.4;
        public static final double SPEED_MULTIPLIER = 1.2;
        public static final double KI_CONSUMPTION = 1.0; // Sem custo adicional
        
        public static boolean canActivate(int healthPercent, boolean wasNearDeath) {
            return wasNearDeath && healthPercent >= 50;
        }
    }
    
    /**
     * Obtém o multiplicador de transformação baseado na raça
     */
    public static double getTransformationMultiplier(RaceEnum race, String transformName) {
        return switch (race) {
            case SAIYAN -> switch (transformName) {
                case "super_saiyan" -> SuperSaiyan.STRENGTH_MULTIPLIER;
                case "golden_form" -> GoldenForm.STRENGTH_MULTIPLIER;
                default -> 1.0;
            };
            case ARCONSIAN -> switch (transformName) {
                case "final_form" -> ArcosianFinalForm.STRENGTH_MULTIPLIER;
                default -> 1.0;
            };
            case HALF -> switch (transformName) {
                case "hybrid_mode" -> HybridMode.STRENGTH_MULTIPLIER;
                default -> 1.0;
            };
            case HUMAN -> switch (transformName) {
                case "zenkai_boost" -> ZenkaiBoost.STRENGTH_MULTIPLIER;
                default -> 1.0;
            };
            default -> 1.0;
        };
    }
}
=== src/main/java/com/dragonblockinfinity/player/PlayerKiManager.java ===
package com.dragonblockinfinity.player;

/**
 * Gerenciador de Ki do Jogador
 * Ki sobe de 1 em 1% a cada tick
 */
public class PlayerKiManager {
    
    private int maxKi;
    private int currentKi;
    private double kiPercentage;
    
    private int regenTicks;
    private int regenTicksNeeded;
    
    public PlayerKiManager(int maxKi) {
        this.maxKi = maxKi;
        this.currentKi = maxKi;
        this.kiPercentage = 100.0;
        this.regenTicksNeeded = 20; // 1 segundo
        this.regenTicks = regenTicksNeeded;
    }
    
    // ===== GETTERS =====
    public int getMaxKi() {
        return maxKi;
    }
    
    public int getCurrentKi() {
        return currentKi;
    }
    
    public double getKiPercentage() {
        return kiPercentage;
    }
    
    public int getTicksUntilNextRegen() {
        return regenTicks;
    }
    
    public double getRegenProgress() {
        return ((double)(regenTicksNeeded - regenTicks) / regenTicksNeeded) * 100.0;
    }
    
    // ===== SETTERS =====
    public void setMaxKi(int maxKi) {
        this.maxKi = maxKi;
        if (currentKi > maxKi) {
            currentKi = maxKi;
            updatePercentage();
        }
    }
    
    public void setRegenSpeed(int ticksPerPercent) {
        this.regenTicksNeeded = Math.max(1, ticksPerPercent);
    }
    
    // ===== KI OPERATIONS =====
    public void consumeKi(int amount) {
        currentKi = Math.max(0, currentKi - amount);
        updatePercentage();
    }
    
    public void consumeKiPercent(double percent) {
        int amount = (int)(maxKi * (percent / 100.0));
        consumeKi(amount);
    }
    
    public void restoreKi(int amount) {
        currentKi = Math.min(currentKi + amount, maxKi);
        updatePercentage();
    }
    
    public void restoreKiPercent(double percent) {
        int amount = (int)(maxKi * (percent / 100.0));
        restoreKi(amount);
    }
    
    public boolean hasKi(int required) {
        return currentKi >= required;
    }
    
    public boolean hasKiPercent(double percent) {
        return kiPercentage >= percent;
    }
    
    // ===== REGENERAÇÃO =====
    /**
     * Ki regenera 1% a cada X ticks
     */
    public void tickRegeneration() {
        if (currentKi >= maxKi) {
            regenTicks = regenTicksNeeded;
            return;
        }
        
        regenTicks--;
        
        if (regenTicks <= 0) {
            // Sobe 1%
            int onePercent = Math.max(1, maxKi / 100);
            currentKi = Math.min(currentKi + onePercent, maxKi);
            updatePercentage();
            regenTicks = regenTicksNeeded;
        }
    }
    
    public void restoreFull() {
        currentKi = maxKi;
        kiPercentage = 100.0;
        regenTicks = regenTicksNeeded;
    }
    
    public void drain() {
        currentKi = 0;
        kiPercentage = 0.0;
    }
    
    public void setKiPercent(double percent) {
        percent = Math.max(0, Math.min(100, percent));
        currentKi = (int)(maxKi * (percent / 100.0));
        updatePercentage();
    }
    
    // ===== PRIVADO =====
    private void updatePercentage() {
        kiPercentage = maxKi <= 0 ? 0.0 : (double) currentKi / maxKi * 100.0;
    }
    
    @Override
    public String toString() {
        return "PlayerKi{" +
                currentKi + "/" + maxKi +
                " (" + String.format("%.1f", kiPercentage) + "%)" +
                "}";
    }
}
=== src/main/java/com/dragonblockinfinity/player/PlayerData.java ===
package com.dragonblockinfinity.player;

import com.dragonblockinfinity.status.Str;
import com.dragonblockinfinity.status.Dex;
import com.dragonblockinfinity.status.Con;
import com.dragonblockinfinity.status.Will;
import com.dragonblockinfinity.status.Spi;
import com.dragonblockinfinity.status.Mnd;

/**
 * Dados completos do jogador em combate
 */
public class PlayerData {
    
    private String playerName;
    private Str strength;
    private Dex dexterity;
    private Con constitution;
    private Will willpower;
    private Spi spirit;
    private Mnd mind;
    private PlayerKiManager kiManager;
    
    public PlayerData(String playerName, int baseStats) {
        this.playerName = playerName;
        
        // Inicializa todos os stats
        this.strength = new Str(baseStats);
        this.dexterity = new Dex(baseStats);
        this.constitution = new Con(baseStats);
        this.willpower = new Will(baseStats, baseStats);
        this.spirit = new Spi(baseStats);
        this.mind = new Mnd(baseStats);
        this.kiManager = new PlayerKiManager(baseStats * 10);
    }
    
    // ===== GETTERS =====
    public String getPlayerName() {
        return playerName;
    }
    
    public Str getStrength() {
        return strength;
    }
    
    public Dex getDexterity() {
        return dexterity;
    }
    
    public Con getConstitution() {
        return constitution;
    }
    
    public Will getWillpower() {
        return willpower;
    }
    
    public Spi getSpirit() {
        return spirit;
    }
    
    public Mnd getMind() {
        return mind;
    }
    
    public PlayerKiManager getKiManager() {
        return kiManager;
    }
    
    // ===== TICK =====
    public void tick() {
        kiManager.tickRegeneration();
        constitution.tickRegeneration();
    }
    
    @Override
    public String toString() {
        return "PlayerData{" +
                "name='" + playerName + '\'' +
                ", Ki=" + kiManager +
                ", Stats=[Str=" + strength.getStrength() +
                ", Con=" + constitution.getConstitution() +
                ", Dex=" + dexterity.getDexterity() +
                ", Will=" + willpower.getWillpower() +
                ", Spi=" + spirit.getSpirit() +
                ", Mnd=" + mind.getMind() +
                "]}";
    }
}
=== src/main/java/com/dragonblockinfinity/event/ClientEvents.java ===
package com.dragonblockinfinity.event;

/**
 * Classe para manipular eventos do lado cliente
 */
public class ClientEvents {
    // Eventos do cliente serão manipulados aqui
}
=== src/main/java/com/dragonblockinfinity/event/ServerEvents.java ===
package com.dragonblockinfinity.event;

/**
 * Classe para manipular eventos do lado servidor
 */
public class ServerEvents {
    // Eventos do servidor serão manipulados aqui
}
=== src/main/java/com/dragonblockinfinity/item/ModItems.java ===
package com.dragonblockinfinity.item;

import com.dragonblockinfinity.DragonBlockInfinity;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.Item;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;

import java.util.ArrayList;
import java.util.List;

/**
 * Registro de itens do mod (DeferredRegister).
 * Varre os assets de item e registra itens automaticamente,
 * exceto os nomes presentes na blacklist.
 */
public class ModItems {

    public static final DeferredRegister<Item> ITEMS = DeferredRegister.create(ForgeRegistries.ITEMS, DragonBlockInfinity.MOD_ID);

    // Blacklist: não registrar itens privados/pesados
    private static final List<String> BLACKLIST = List.of("peso", "weightshirt", "Flying_Nimbus", "fly_ninbus", "dark_fly_ninbus");

    // Itens detectados manualmente do diretório de texturas (preenchido com os PNGs já presentes no repo)
    private static final String[] AUTO_ITEMS = new String[]{
            // comida folder
            "dino_meat",
            "dino_meat_cooked",
            "senzu",
            // ninbus folder (exceto blacklist entries)
            "dragon_esfer",
            "esfera_dragon_earth",
            "radar",
            // pesos folder (skip peso, weightshirt)
            // scouter
            "scouter"
    };

    // Registrations list (optional access)
    public static final List<RegistryObject<Item>> REGISTERED = new ArrayList<>();

    static {
        for (String name : AUTO_ITEMS) {
            String key = name.toLowerCase();
            if (BLACKLIST.contains(name) || BLACKLIST.contains(key)) continue;
            RegistryObject<Item> reg = ITEMS.register(key, () -> new Item(new Item.Properties()));
            REGISTERED.add(reg);
        }
        // Mantemos scouter como destaque (já incluso acima)
    }

    public static void register(IEventBus bus) {
        ITEMS.register(bus);
    }
}
=== src/main/java/com/dragonblockinfinity/handler/KeyBindings.java ===
package com.dragonblockinfinity.handler;

import com.mojang.blaze3d.platform.InputConstants;
import net.minecraft.client.KeyMapping;
import org.lwjgl.glfw.GLFW;

public class KeyBindings {
    public static final String CATEGORY = "Dragon Block Infinity";

    public static final KeyMapping OPEN_CUSTOMIZATION_KEY = new KeyMapping(
            "key.dragonblockinfinity.customization",
            InputConstants.Type.KEYSYM,
            GLFW.GLFW_KEY_C,
            CATEGORY
    );
}
=== src/main/java/com/dragonblockinfinity/handler/KeyHandler.java ===
package com.dragonblockinfinity.handler;

import com.mojang.blaze3d.platform.InputConstants;
import net.minecraft.client.Minecraft;
import net.minecraft.client.KeyMapping;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.client.event.RegisterKeyMappingsEvent;
import net.minecraftforge.client.event.InputEvent;
import net.minecraftforge.event.TickEvent.ClientTickEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;
import org.lwjgl.glfw.GLFW;
import com.dragonblockinfinity.screen.CustomizationScreen;

/**
 * Classe para manipular eventos de teclado
 */
@Mod.EventBusSubscriber(modid = "dragonblockinfinity", bus = Mod.EventBusSubscriber.Bus.FORGE, value = Dist.CLIENT)
public class KeyHandler {

    @SubscribeEvent
    public static void onClientTick(ClientTickEvent event) {
        if (Minecraft.getInstance().screen == null && KeyBindings.OPEN_CUSTOMIZATION_KEY.consumeClick()) {
            Minecraft.getInstance().setScreen(new CustomizationScreen());
        }
    }
}

=== src/main/java/com/dragonblockinfinity/handler/KeyRegistration.java ===
package com.dragonblockinfinity.handler;

import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.client.event.RegisterKeyMappingsEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

@Mod.EventBusSubscriber(modid = "dragonblockinfinity", bus = Mod.EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)
public class KeyRegistration {

    @SubscribeEvent
    public static void registerKeyMappings(RegisterKeyMappingsEvent event) {
        event.register(KeyBindings.OPEN_CUSTOMIZATION_KEY);
    }
}
=== src/main/java/com/dragonblockinfinity/block/ModBlocks.java ===
package com.dragonblockinfinity.block;

import com.dragonblockinfinity.DragonBlockInfinity;
import com.dragonblockinfinity.item.ModItems;
import net.minecraft.world.item.BlockItem;
import net.minecraft.world.item.Item;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.SoundType;
import net.minecraft.world.level.block.state.BlockBehaviour;
import net.minecraft.world.level.block.Blocks;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;

/**
 * Classe para registro de blocos customizados do Dragon Block Infinity
 */
public class ModBlocks {

    public static final DeferredRegister<Block> BLOCKS = DeferredRegister.create(ForgeRegistries.BLOCKS, DragonBlockInfinity.MOD_ID);

        public static final RegistryObject<Block> DIRTY_STONE = BLOCKS.register("dirty_stone",
            () -> new Block(BlockBehaviour.Properties.copy(Blocks.STONE).strength(1.5f, 6.0f).sound(SoundType.STONE)));

        // namek_stone removed per user request (uses vanilla stone)

    public static void register(IEventBus bus) {
        // Registrar blocos
        BLOCKS.register(bus);

        // Registrar BlockItems para aparecer no inventário — adiciona ao DeferredRegister de itens
        ModItems.ITEMS.register("dirty_stone", () -> new BlockItem(DIRTY_STONE.get(), new Item.Properties()));
    }
}

=== src/main/resources/assets/dragonblockinfinity/lang/pt_br.json ===
{
  "key.dragonblockinfinity.customization": "Abrir Menu de Customização",
  "item.dragonblockinfinity.scouter": "Scouter",
  "item.dragonblockinfinity.nimbus": "Nuvem Nimbus",
  "item.dragonblockinfinity.peso": "Peso de Treino",
  "item.dragonblockinfinity.comida": "Comida"
  ,"item.dragonblockinfinity.dino_meat": "Carne de Dinossauro"
  ,"item.dragonblockinfinity.dino_meat_cooked": "Carne de Dinossauro Cozida"
  ,"item.dragonblockinfinity.senzu": "Semente Senzu"
  ,"item.dragonblockinfinity.dragon_esfer": "Esfera do Dragão"
  ,"item.dragonblockinfinity.esfera_dragon_earth": "Esfera da Terra"
  ,"item.dragonblockinfinity.radar": "Radar"
  ,"block.dragonblockinfinity.dirty_stone": "Pedra Suja"
}
=== src/main/resources/assets/dragonblockinfinity/lang/en_us.json ===
{
  "key.dragonblockinfinity.customization": "Open Customization Menu",
  "item.dragonblockinfinity.scouter": "Scouter",
  "item.dragonblockinfinity.nimbus": "Flying Nimbus",
  "item.dragonblockinfinity.peso": "Training Weight",
  "item.dragonblockinfinity.comida": "Food"
  ,"item.dragonblockinfinity.dino_meat": "Dinosaur Meat"
  ,"item.dragonblockinfinity.dino_meat_cooked": "Cooked Dinosaur Meat"
  ,"item.dragonblockinfinity.senzu": "Senzu Bean"
  ,"item.dragonblockinfinity.dragon_esfer": "Dragon Orb"
  ,"item.dragonblockinfinity.esfera_dragon_earth": "Dragon Earth Orb"
  ,"item.dragonblockinfinity.radar": "Radar"
  ,"block.dragonblockinfinity.dirty_stone": "Dirty Stone"
}
=== src/main/resources/assets/dragonblockinfinity/models/item/nimbus.json ===
{
  "parent": "item/handheld",
  "textures": {
    "layer0": "dragonblockinfinity:item/ninbus/fly_ninbus"
  },
  "display": {
    "thirdperson_righthand": { "rotation": [ 75, -10, 0 ], "translation": [ 0, 2.5, 0 ], "scale": [ 0.375, 0.375, 0.375 ] },
    "firstperson_righthand": { "rotation": [ 0, -135, 25 ], "translation": [ 0, 4, 2 ], "scale": [ 0.5, 0.5, 0.5 ] },
    "gui": { "rotation": [ 30, -135, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.625, 0.625, 0.625 ] },
    "ground": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 3, 0 ], "scale": [ 0.25, 0.25, 0.25 ] },
    "fixed": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.5, 0.5, 0.5 ] }
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/item/dragon_esfer.json ===
{
  "parent": "item/generated",
  "textures": {
    "layer0": "dragonblockinfinity:item/ninbus/dragon_esfer"
  },
  "display": {
    "gui": { "rotation": [ 30, -135, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.625, 0.625, 0.625 ] },
    "ground": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 3, 0 ], "scale": [ 0.5, 0.5, 0.5 ] },
    "fixed": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.5, 0.5, 0.5 ] }
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/item/senzu.json ===
{
  "parent": "item/generated",
  "textures": {
    "layer0": "dragonblockinfinity:item/comida/senzu"
  },
  "display": {
    "gui": { "rotation": [ 30, -135, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.625, 0.625, 0.625 ] },
    "ground": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 3, 0 ], "scale": [ 0.5, 0.5, 0.5 ] },
    "fixed": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.5, 0.5, 0.5 ] }
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/item/dino_meat_cooked.json ===
{
  "parent": "item/generated",
  "textures": {
    "layer0": "dragonblockinfinity:item/comida/dino_meat_cooked"
  },
  "display": {
    "gui": { "rotation": [ 30, -135, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.625, 0.625, 0.625 ] },
    "ground": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 3, 0 ], "scale": [ 0.5, 0.5, 0.5 ] },
    "fixed": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.5, 0.5, 0.5 ] }
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/item/radar.json ===
{
  "parent": "item/generated",
  "textures": {
    "layer0": "dragonblockinfinity:item/ninbus/radar"
  },
  "display": {
    "gui": { "rotation": [ 30, -135, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.625, 0.625, 0.625 ] },
    "ground": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 3, 0 ], "scale": [ 0.5, 0.5, 0.5 ] },
    "fixed": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.5, 0.5, 0.5 ] }
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/item/comida.json ===
{
  "parent": "item/generated",
  "textures": {
    "layer0": "dragonblockinfinity:item/comida/comida"
  },
  "display": {
    "gui": { "rotation": [ 30, -135, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.625, 0.625, 0.625 ] },
    "ground": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 3, 0 ], "scale": [ 0.5, 0.5, 0.5 ] },
    "fixed": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.5, 0.5, 0.5 ] }
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/item/dirty_stone.json ===
{
  "parent": "dragonblockinfinity:block/dirty_stone"
}
=== src/main/resources/assets/dragonblockinfinity/models/item/namek_stone.json ===
{
  "parent": "dragonblockinfinity:block/namek_stone"
}
=== src/main/resources/assets/dragonblockinfinity/models/item/dino_meat.json ===
{
  "parent": "item/generated",
  "textures": {
    "layer0": "dragonblockinfinity:item/comida/dino_meat"
  },
  "display": {
    "gui": { "rotation": [ 30, -135, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.625, 0.625, 0.625 ] },
    "ground": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 3, 0 ], "scale": [ 0.5, 0.5, 0.5 ] },
    "fixed": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.5, 0.5, 0.5 ] }
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/item/peso.json ===
{
  "parent": "item/handheld",
  "textures": {
    "layer0": "dragonblockinfinity:item/pesos/peso"
  },
  "display": {
    "thirdperson_righthand": { "rotation": [ 75, -10, 0 ], "translation": [ 0, 2.5, 0 ], "scale": [ 0.375, 0.375, 0.375 ] },
    "firstperson_righthand": { "rotation": [ 0, -135, 25 ], "translation": [ 0, 4, 2 ], "scale": [ 0.45, 0.45, 0.45 ] },
    "gui": { "rotation": [ 30, -135, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.625, 0.625, 0.625 ] },
    "ground": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 3, 0 ], "scale": [ 0.25, 0.25, 0.25 ] },
    "fixed": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.5, 0.5, 0.5 ] }
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/item/scouter.json ===
{
  "parent": "item/handheld",
  "textures": {
    "layer0": "dragonblockinfinity:item/scouter/scouter"
  },
  "display": {
    "thirdperson_righthand": { "rotation": [ 75, -10, 0 ], "translation": [ 0, 2.5, 0 ], "scale": [ 0.375, 0.375, 0.375 ] },
    "firstperson_righthand": { "rotation": [ 0, -135, 25 ], "translation": [ 0, 4, 2 ], "scale": [ 0.4, 0.4, 0.4 ] },
    "gui": { "rotation": [ 30, -135, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.625, 0.625, 0.625 ] },
    "ground": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 3, 0 ], "scale": [ 0.25, 0.25, 0.25 ] },
    "fixed": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.5, 0.5, 0.5 ] }
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/item/esfera_dragon_earth.json ===
{
  "parent": "item/generated",
  "textures": {
    "layer0": "dragonblockinfinity:item/ninbus/esfera_dragon_earth"
  },
  "display": {
    "gui": { "rotation": [ 30, -135, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.625, 0.625, 0.625 ] },
    "ground": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 3, 0 ], "scale": [ 0.5, 0.5, 0.5 ] },
    "fixed": { "rotation": [ 0, 0, 0 ], "translation": [ 0, 0, 0 ], "scale": [ 0.5, 0.5, 0.5 ] }
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/block/dirty_stone.json ===
{
  "parent": "block/cube_all",
  "textures": {
    "all": "dragonblockinfinity:block/dirty_stone_stone"
  }
}
=== src/main/resources/assets/dragonblockinfinity/models/block/namek_stone.json ===
{
  "parent": "block/cube_all",
  "textures": {
    "all": "minecraft:block/stone"
  }
}
=== src/main/resources/assets/dragonblockinfinity/textures/gui/huds/ki_bar_good_fx.png.mcmeta ===
{
  "animation": {
    "frametime": 3,
    "interpolate": true
  }
}=== src/main/resources/assets/dragonblockinfinity/textures/gui/huds/ki_attck_charging.png.mcmeta ===
{
  "animation": {
    "frametime": 2,
    "interpolate": true
  }
}=== src/main/resources/assets/dragonblockinfinity/textures/particules/hit_clash.png.mcmeta ===
{
  "animation": {
    "frametime": 1,
    "interpolate": true
  }
}=== src/main/resources/assets/dragonblockinfinity/textures/particules/aura/ki_aura.png.mcmeta ===
{
  "animation": {
    "frametime": 3,
    "interpolate": false
  }
}=== src/main/resources/assets/dragonblockinfinity/textures/particules/aura/ki_aura_ssj2.png.mcmeta ===
{
  "animation": {
    "frametime": 2,
    "interpolate": true
  }
}=== src/main/resources/assets/dragonblockinfinity/textures/particules/aura/ki_aura_ssj1.png.mcmeta ===
{
  "animation": {
    "frametime": 4,
    "interpolate": true
  }
}=== src/main/resources/assets/dragonblockinfinity/textures/particules/aura/ki_aura_ssj3.png.mcmeta ===
{
  "animation": {
    "frametime": 5,
    "interpolate": true
  }
}=== src/main/resources/assets/dragonblockinfinity/blockstates/dirty_stone.json ===
{
  "variants": {
    "": { "model": "dragonblockinfinity:block/dirty_stone" }
  }
}
=== src/main/resources/assets/dragonblockinfinity/blockstates/namek_stone.json ===
{
  "variants": {
    "": { "model": "dragonblockinfinity:block/namek_stone" }
  }
}
=== src/main/resources/META-INF/mods.toml ===
modLoader="javafml"
loaderVersion="[47,)"
license="All Rights Reserved"

[[mods]]
modId="dragonblockinfinity"
version="1.0.0"
displayName="Dragon Block Infinity"
description="A Dragon Ball mod for Minecraft Forge 1.20.1"

[[dependencies.dragonblockinfinity]]
modId="forge"
mandatory=true
versionRange="[47,)"
ordering="NONE"
side="BOTH"

[[dependencies.dragonblockinfinity]]
modId="minecraft"
mandatory=true
versionRange="[1.20.1]"
ordering="NONE"
side="BOTH"
=== src/main/resources/data/dragonblockinfinity/loot_tables/blocks/dirty_stone.json ===
{
  "type": "minecraft:block",
  "pools": [
    {
      "rolls": 1,
      "entries": [
        {
          "type": "minecraft:item",
          "name": "minecraft:stone"
        }
      ],
      "conditions": [
        {
          "condition": "minecraft:survives_explosion"
        }
      ]
    }
  ]
}
=== src/main/resources/pack.mcmeta ===
{
  "pack": {
    "pack_format": 15,
    "description": "Dragon Block Infinity resources"
  }
}


=== LISTA DE TEXTURAS ===
src/main/resources/assets/dragonblockinfinity/textures/entity/customização/eye/eye_1_left.png
src/main/resources/assets/dragonblockinfinity/textures/entity/customização/eye/eye_1_right.png
src/main/resources/assets/dragonblockinfinity/textures/entity/tail/t_s_fs.png
src/main/resources/assets/dragonblockinfinity/textures/entity/tail/tail_arconsian.png
src/main/resources/assets/dragonblockinfinity/textures/entity/race/arconsian.png
src/main/resources/assets/dragonblockinfinity/textures/entity/race/humano.png
src/main/resources/assets/dragonblockinfinity/textures/entity/race/sayajin.png
src/main/resources/assets/dragonblockinfinity/textures/entity/race/fsayajin.png
src/main/resources/assets/dragonblockinfinity/textures/entity/musculosrace/musculos.png
src/main/resources/assets/dragonblockinfinity/textures/entity/musculosrace/musculos_arconsian.png
src/main/resources/assets/dragonblockinfinity/textures/entity/aura.png
src/main/resources/assets/dragonblockinfinity/textures/gui/menus/mn.png
src/main/resources/assets/dragonblockinfinity/textures/gui/menus/menu_base.png
src/main/resources/assets/dragonblockinfinity/textures/gui/buttoes/rtn.png
src/main/resources/assets/dragonblockinfinity/textures/gui/buttoes/mais.png
src/main/resources/assets/dragonblockinfinity/textures/gui/buttoes/x.png
src/main/resources/assets/dragonblockinfinity/textures/gui/buttoes/seta_left.png
src/main/resources/assets/dragonblockinfinity/textures/gui/buttoes/seta_right.png
src/main/resources/assets/dragonblockinfinity/textures/gui/buttoes/rt.png
src/main/resources/assets/dragonblockinfinity/textures/gui/buttoes/maiss.png
src/main/resources/assets/dragonblockinfinity/textures/gui/huds/health.png
src/main/resources/assets/dragonblockinfinity/textures/gui/huds/ki_bar_good_fx.png
src/main/resources/assets/dragonblockinfinity/textures/gui/huds/ki_bar_good_empty.png
src/main/resources/assets/dragonblockinfinity/textures/gui/huds/ki_bar_good.png
src/main/resources/assets/dragonblockinfinity/textures/gui/huds/ki_attck_chargin.png
src/main/resources/assets/dragonblockinfinity/textures/particules/hit_clash.png
src/main/resources/assets/dragonblockinfinity/textures/particules/aura/ki_aura_ssj1.png
src/main/resources/assets/dragonblockinfinity/textures/particules/aura/ki_aura.png
src/main/resources/assets/dragonblockinfinity/textures/particules/aura/ki_aura_ssj3.png
src/main/resources/assets/dragonblockinfinity/textures/particules/aura/ki_aura_ssj2.png
src/main/resources/assets/dragonblockinfinity/textures/item/ninbus/dragon_esfer.png
src/main/resources/assets/dragonblockinfinity/textures/item/ninbus/radar.png
src/main/resources/assets/dragonblockinfinity/textures/item/ninbus/dark_fly_ninbus.png
src/main/resources/assets/dragonblockinfinity/textures/item/ninbus/esfera_dragon_earth.png
src/main/resources/assets/dragonblockinfinity/textures/item/ninbus/Flying_Nimbus.png
src/main/resources/assets/dragonblockinfinity/textures/item/ninbus/fly_ninbus.png
src/main/resources/assets/dragonblockinfinity/textures/item/scouter/scouter.png
src/main/resources/assets/dragonblockinfinity/textures/item/pesos/peso.png
src/main/resources/assets/dragonblockinfinity/textures/item/pesos/weightshirt.png
src/main/resources/assets/dragonblockinfinity/textures/item/comida/dino_meat_cooked.png
src/main/resources/assets/dragonblockinfinity/textures/item/comida/senzu.png
src/main/resources/assets/dragonblockinfinity/textures/item/comida/dino_meat.png
src/main/resources/assets/dragonblockinfinity/textures/blocks/namek_grass_top.png
src/main/resources/assets/dragonblockinfinity/textures/blocks/dirty_stone_stone.png
src/main/resources/assets/dragonblockinfinity/textures/blocks/namek_side.png
src/main/resources/assets/dragonblockinfinity/textures/blocks/dirty_stone_dirty.png
